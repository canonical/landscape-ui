import _pt from "prop-types";
var _excluded = ["existingSearchData", "filterPanelData", "returnSearchData", "onPanelToggle", "onExpandChange"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React, { useState, useEffect, useRef } from "react";
import FilterPanelSection from "./FilterPanelSection";
import Chip from "../Chip";
import { overflowingChipsCount, isChipInArray } from "./utils";
import { useOnEscapePressed, useWindowFitment } from "../../hooks";
export var Label = /*#__PURE__*/function (Label) {
  Label["AddFilter"] = "Add filter";
  Label["Clear"] = "Clear input";
  Label["SearchAndFilter"] = "Search and filter";
  return Label;
}({});
/**
 * This component allows searching and filtering of large datasets.
 */
var SearchAndFilter = _ref => {
  var {
      existingSearchData = [],
      filterPanelData,
      returnSearchData,
      onPanelToggle = () => {},
      onExpandChange = () => {}
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  var [searchData, setSearchData] = useState(existingSearchData);
  var [searchTerm, setSearchTerm] = useState("");
  var [filterPanelHidden, setFilterPanelHidden] = useState(true);
  var [searchBoxExpanded, setSearchBoxExpanded] = useState(false);
  var [overflowSearchTermCounter, setOverflowSearchTermCounter] = useState(0);
  var [searchContainerActive, setSearchContainerActive] = useState(false);
  var [maxHeight, setMaxHeight] = useState();
  var searchAndFilterRef = useRef(null);
  var searchContainerRef = useRef(null);
  var searchBoxRef = useRef(null);
  var panel = useRef(null);

  // Call onPanelToggle when the filterPanelHidden state changes
  useEffect(onPanelToggle, [onPanelToggle, filterPanelHidden]);

  // Call onExpandChange when the search box is expanded or collapsed
  useEffect(onExpandChange, [onExpandChange, searchBoxExpanded]);

  // Return searchData to parent component
  useEffect(() => {
    var mounted = true;
    returnSearchData && mounted && returnSearchData(searchData);
    return () => {
      mounted = false;
    };
  }, [searchData, returnSearchData]);

  // Hide manual input form field when search container is inactive
  useEffect(() => {
    var searchContainerClickCheck = e => {
      var _e$target;
      var clickInContainer = ((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest(".p-search-and-filter")) !== null;
      setSearchContainerActive(clickInContainer);
    };
    document.addEventListener("click", searchContainerClickCheck);
    return () => {
      document.removeEventListener("click", searchContainerClickCheck);
    };
  }, [searchContainerActive]);
  var closePanel = () => {
    setFilterPanelHidden(true);
  };
  useOnEscapePressed(() => closePanel());

  // This useEffect sets up listeners so the panel will close if user clicks
  // anywhere else on the page or hits the escape key
  useEffect(() => {
    var mouseDown = e => {
      var _searchAndFilterRef$c;
      // Check if click is outside of filter panel
      if (!(searchAndFilterRef !== null && searchAndFilterRef !== void 0 && (_searchAndFilterRef$c = searchAndFilterRef.current) !== null && _searchAndFilterRef$c !== void 0 && _searchAndFilterRef$c.contains(e.target))) {
        // If so, close the panel
        closePanel();
      }
    };

    // Add listener on document to capture click events
    document.addEventListener("mousedown", mouseDown);
    // return function to be called when unmounted
    return () => {
      document.removeEventListener("mousedown", mouseDown);
    };
  }, []);

  // Add passed chip to the searchData array
  var toggleSelected = chip => {
    var currentSelected = [...searchData];
    if (!isChipInArray(chip, currentSelected)) {
      currentSelected.push(chip);
      setSearchData(currentSelected);
      setSearchTerm("");
    } else {
      var updatedCurrentSelected = currentSelected.filter(currentSelectedChip => {
        return currentSelectedChip.value !== chip.value;
      });
      setSearchData(updatedCurrentSelected);
    }
  };

  // Remove passed chip from the searchData array
  var removeFromSelected = chip => {
    if (searchData.includes(chip)) {
      var updatedSelected = searchData.filter(searchDataChip => searchDataChip !== chip);
      setSearchData(updatedSelected);
    }
  };

  // When overflow chips are shown, clicking anywhere outside search area
  // or clicking on a chip should hide them again
  useEffect(() => {
    var hideOverflowChips = e => {
      if (!e.target.closest(".p-search-and-filter") && e.target.className !== "p-icon--close") {
        setSearchBoxExpanded(false);
      }
    };
    document.addEventListener("click", e => {
      hideOverflowChips(e);
    });
    return () => {
      document.removeEventListener("click", e => {
        hideOverflowChips(e);
      });
    };
  }, []);
  var handleSubmit = () => {
    if (searchTerm.trim() !== "") {
      toggleSelected({
        value: searchTerm,
        quoteValue: true
      });
      setSearchTerm("");
    }
  };

  // If the offsetTop is more than double height of a single chip, consider it
  // overflowing
  var updateFlowCount = function updateFlowCount() {
    var _searchContainerRef$c;
    var chips = searchContainerRef === null || searchContainerRef === void 0 || (_searchContainerRef$c = searchContainerRef.current) === null || _searchContainerRef$c === void 0 ? void 0 : _searchContainerRef$c.querySelectorAll(".p-chip");
    var overflowCount = overflowingChipsCount(chips, 1);
    setOverflowSearchTermCounter(overflowCount);
  };

  // Watch for container resize and recalculate overflow count accordingly
  useEffect(() => {
    var resizeObserverSupported = typeof ResizeObserver !== "undefined";
    var wrapper = searchContainerRef.current;
    var wrapperWidthObserver;
    if (resizeObserverSupported && wrapper) {
      wrapperWidthObserver = new ResizeObserver(() => {
        updateFlowCount();
      });
      wrapperWidthObserver.observe(wrapper);
    } else {
      updateFlowCount();
    }
    return () => {
      var _wrapperWidthObserver;
      resizeObserverSupported && ((_wrapperWidthObserver = wrapperWidthObserver) === null || _wrapperWidthObserver === void 0 ? void 0 : _wrapperWidthObserver.disconnect());
    };
  }, [searchData]);
  useWindowFitment(panel.current, searchAndFilterRef.current, fitsWindow => setMaxHeight(fitsWindow.fromBottom.spaceBelow - 16), 0, !filterPanelHidden);

  // Add search prompt value to search on Enter key
  var searchPromptKeyDown = e => {
    if (e.key === "Enter") {
      handleSubmit();
    }
  };
  var searchBox = searchBoxRef.current;
  var searchContainer = searchContainerRef.current;
  if (!searchBoxExpanded && searchBox && searchContainer && overflowSearchTermCounter === 0) {
    if (searchBox.offsetTop > searchContainer.offsetHeight) {
      setSearchBoxExpanded(true);
    }
  }

  // If chips or input field contains values, clear 'em out
  var clearAllSearchTerms = () => {
    setSearchTerm("");
  };
  var placeholder = searchData.length ? Label.AddFilter : Label.SearchAndFilter;
  return /*#__PURE__*/React.createElement("div", _extends({
    className: "p-search-and-filter",
    ref: searchAndFilterRef,
    onClick: () => filterPanelHidden && setFilterPanelHidden(false)
  }, props), /*#__PURE__*/React.createElement("div", {
    className: "p-search-and-filter__search-container",
    "aria-expanded": searchBoxExpanded,
    "data-active": searchContainerActive || searchData.length === 0,
    "data-empty": searchData.length <= 0,
    ref: searchContainerRef
  }, searchTerm !== "" && /*#__PURE__*/React.createElement("button", {
    "aria-label": Label.Clear,
    className: "p-search-and-filter__clear",
    onClick: () => clearAllSearchTerms()
  }, /*#__PURE__*/React.createElement("i", {
    className: "p-icon--close"
  })), Object.values(searchData).map(chip => {
    return /*#__PURE__*/React.createElement(Chip, {
      lead: chip.lead,
      value: chip.value,
      key: "search-".concat(chip.lead, "+").concat(chip.value),
      onDismiss: event => {
        // Prevent filter chip dismissals from bubbling up and triggering the parent onClick handler
        event.stopPropagation();
        removeFromSelected(chip);
      },
      selected: true,
      quoteValue: chip.quoteValue
    });
  }), /*#__PURE__*/React.createElement("form", {
    className: "p-search-and-filter__box",
    onSubmit: e => {
      e.preventDefault();
      handleSubmit();
    },
    "data-overflowing": searchBoxExpanded,
    ref: searchBoxRef
  }, /*#__PURE__*/React.createElement("label", {
    className: "u-off-screen",
    htmlFor: "search-and-filter-input"
  }, searchData.length ? Label.AddFilter : Label.SearchAndFilter), /*#__PURE__*/React.createElement("input", {
    autoComplete: "off",
    className: "p-search-and-filter__input",
    id: "search-and-filter-input",
    name: "search",
    onChange: e => setSearchTerm(e.target.value),
    placeholder: placeholder,
    type: "search",
    value: searchTerm
  }), /*#__PURE__*/React.createElement("button", {
    className: "u-off-screen",
    type: "submit"
  }, "Search")), overflowSearchTermCounter > 0 && /*#__PURE__*/React.createElement("span", {
    className: "p-search-and-filter__selected-count",
    onClick: () => setSearchBoxExpanded(true),
    onKeyDown: () => setSearchBoxExpanded(true),
    role: "button",
    tabIndex: 0
  }, "+", overflowSearchTermCounter)), (filterPanelData.length > 0 || searchTerm.length > 0) && /*#__PURE__*/React.createElement("div", {
    className: "p-search-and-filter__panel",
    "aria-hidden": filterPanelHidden,
    ref: panel,
    style: {
      maxHeight,
      minHeight: "5rem",
      overflowX: "auto"
    }
  }, /*#__PURE__*/React.createElement("div", null, searchTerm.length > 0 && /*#__PURE__*/React.createElement("div", {
    className: "p-search-and-filter__search-prompt",
    onClick: () => handleSubmit(),
    onKeyDown: e => searchPromptKeyDown(e),
    role: "button",
    tabIndex: 0
  }, "Search for", " ", /*#__PURE__*/React.createElement("span", {
    className: "p-search-and-filter__search-query"
  }, searchTerm), "..."), filterPanelData.map(filterPanelSectionData => {
    return /*#__PURE__*/React.createElement(FilterPanelSection, {
      key: filterPanelSectionData.id,
      data: filterPanelSectionData,
      toggleSelected: toggleSelected,
      searchData: searchData,
      searchTerm: searchTerm,
      sectionHidden: filterPanelHidden
    });
  }))));
};
SearchAndFilter.propTypes = {
  existingSearchData: _pt.array,
  filterPanelData: _pt.array.isRequired,
  returnSearchData: _pt.func.isRequired,
  onPanelToggle: _pt.func,
  onExpandChange: _pt.func
};
export default SearchAndFilter;