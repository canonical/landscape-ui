function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
import { failure as _failure, info as _info, caution as _caution, success as _success } from "../../NotificationProvider";
import ToastNotification from "./ToastNotification";
import ToastNotificationList from "./ToastNotificationList";
import { createContext, useContext, useEffect, useState } from "react";
import React from "react";
var HIDE_NOTIFICATION_DELAY = 5000;
var initialNotification = {
  id: "",
  message: "",
  type: "positive"
};
var ToastNotificationContext = /*#__PURE__*/createContext({
  /** List of all active toast notifications */
  notifications: [],
  /** Show a success toast. Optionally pass actions and a title. */
  success: () => initialNotification,
  /** Show an info toast. Optionally pass a custom title and actions. */
  info: () => initialNotification,
  /** Show a failure toast with an error and optional message/actions. */
  failure: () => initialNotification,
  /** Show a caution toast. Optionally pass actions and a title. */
  caution: () => initialNotification,
  /** Clear one or more specific toasts, or all if none provided. */
  clear: () => null,
  /** Toggle between single toast view and list view. */
  toggleListView: () => null,
  /** Whether the notification list view is currently open. */
  isListView: false,
  /** Grouped count of notifications by severity (positive, info, etc.). */
  countBySeverity: {}
});

/**
 * The `ToastNotificationProvider` can be used to manage toast notifications.

Wrap your application with this provider, and in any child component you can get the helper with `const toastNotify = useToastNotification()` to trigger notifications.
Notifications automatically dismiss after a delay unless manually dismissed or expanded.

To make the notification persistent (i.e., not auto-dismiss), set the `autoDismissDelay` prop to `0` when using the provider: `<ToastNotificationProvider autoDismissDelay={0}>`

| **Values**                       | **Description**                                                                |
|----------------------------------|--------------------------------------------------------------------------------|
| `toastNotify.success()`          | Displays a success toast. Optionally accepts actions and a title.              |
| `toastNotify.info()`             | Displays an info toast. Optionally accepts a custom title.                     |
| `toastNotify.failure()`          | Displays a failure toast with an error and optional message or actions.        |
| `toastNotify.caution()`          | Displays a caution toast. Optionally accepts actions and a title.              |
| `toastNotify.clear()`            | Clears specific toasts, or all toasts if none are specified.                   |
| `toastNotify.toggleListView()`   | Toggles the notification list view open or closed.                             |
| `toastNotify.countBySeverity`    | Returns the count of notifications grouped by severity (e.g., success, info).  |

Some example usages:

1. **Show a success toast:**
```
toastNotify.success("Your changes have been saved.");
toastNotify.success("Your changes have been saved.", [{label: "Undo", onClick: () => console.log("Undo clicked")}]);
```

2. **Show an info toast:**
```
toastNotify.info("Your changes are syncing in the background.");
toastNotify.info("Your changes are syncing in the background.", "Syncing");
```

3. **Show a failure toast:**
```
toastNotify.failure("Save failed", new Error("500 Internal Server Error"), "Please try again.");
toastNotify.failure("Save failed", new Error("500 Internal Server Error"), "Please try again.", [{label: "Retry", onClick: () => console.log("Retry clicked")}]);
```

4. **Show a caution toast:**
```
toastNotify.caution("Your changes have not been saved.");
toastNotify.caution("Your changes have not been saved.", [{label: "Undo", onClick: () => console.log("Undo clicked")}]);
```

5. **Clear notifications:**
```
toastNotify.clear(); // clears all toast notifications
toastNotify.clear([notificationId]); // clears specific toast notifications
```

6. **Toggle the notification list view:**
```
toastNotify.toggleListView();
```

7. **Get the count of notifications by severity:**
```
const count = toastNotify.countBySeverity;
console.log(count.positive);
```

Alternatively, you can use the `ToastNotification` and `ToastNotificationList` components directly, without using the provider.
*/

var ToastNotificationProvider = _ref => {
  var {
    children,
    onDismiss,
    autoDismissDelay = HIDE_NOTIFICATION_DELAY
  } = _ref;
  var [notifications, setNotifications] = useState([]);
  var [showList, setShowList] = useState(false);
  var [notificationTimer, setNotificationTimer] = useState(null);

  // cleanup on timer if unmounted
  useEffect(() => {
    return () => {
      if (notificationTimer && typeof notificationTimer !== "boolean") {
        clearTimeout(notificationTimer);
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  var showNotificationWithDelay = () => {
    setNotificationTimer(prevTimer => {
      if (prevTimer && typeof prevTimer !== "boolean") {
        clearTimeout(prevTimer);
      }
      if (!showList) {
        // If autoDismissDelay is 0, make notification persistent (no auto-hide)
        if (!autoDismissDelay) {
          return true; // Set a truthy value to indicate notification should show
        }
        return setTimeout(() => {
          setNotificationTimer(null);
        }, autoDismissDelay);
      }
      return null;
    });
  };
  var clearNotificationTimer = () => {
    setNotificationTimer(prevTimer => {
      if (prevTimer && typeof prevTimer !== "boolean") {
        clearTimeout(prevTimer);
      }
      return null;
    });
  };
  var pauseTimer = () => {
    if (notificationTimer && typeof notificationTimer !== "boolean") {
      clearTimeout(notificationTimer);
      setNotificationTimer(true); // mark as paused
    }
  };
  var resumeTimer = () => {
    if (notificationTimer === true) {
      // only resume if previously paused
      showNotificationWithDelay();
    }
  };
  var addNotification = notification => {
    var _notification$id;
    var notificationToAdd = _objectSpread(_objectSpread({}, notification), {}, {
      timestamp: new Date().toLocaleString(),
      id: (_notification$id = notification.id) !== null && _notification$id !== void 0 ? _notification$id : Date.now().toString() + (Math.random() + 1).toString(36).substring(7)
    });
    setNotifications(prev => {
      return [...prev, notificationToAdd];
    });
    showNotificationWithDelay();
    return notificationToAdd;
  };
  var clear = notifications => {
    if (onDismiss) {
      onDismiss(notifications);
    }
    if (!notifications) {
      setNotifications([]);
      setShowList(false);
      clearNotificationTimer();
      return;
    }
    setNotifications(prev => {
      var removeIdLookup = new Set(notifications);
      var newNotifications = prev.filter(item => !removeIdLookup.has(item));

      // if we are clearing the last notification from an expanded list,
      // then we want to collapse the list as well if all notifications has been cleared
      if (!newNotifications.length) {
        setShowList(false);
      }
      return newNotifications;
    });
    clearNotificationTimer();
  };
  var toggleListView = () => {
    clearNotificationTimer();
    setShowList(prev => !prev);
  };
  var countBySeverity = {
    positive: 0,
    negative: 0,
    caution: 0,
    information: 0
  };
  notifications.forEach(notification => {
    countBySeverity[notification.type] += 1;
  });
  var helper = {
    notifications,
    failure: (title, error, message, actions, id) => addNotification(_objectSpread(_objectSpread({}, _failure(title, error, message, actions)), {}, {
      id
    })),
    info: (message, title, actions, id) => addNotification(_objectSpread(_objectSpread({}, _info(message, title, actions)), {}, {
      id
    })),
    success: (message, actions, title, id) => addNotification(_objectSpread(_objectSpread({}, _success(message, title, actions)), {}, {
      id
    })),
    caution: (message, actions, title, id) => addNotification(_objectSpread(_objectSpread({}, _caution(message, title, actions)), {}, {
      id
    })),
    clear,
    toggleListView,
    isListView: showList,
    countBySeverity
  };
  var latestNotification = notifications[notifications.length - 1];
  var hasNotifications = !!notifications.length;
  var showNotification = hasNotifications && !showList && notificationTimer;
  var showNotificationList = hasNotifications && showList;
  return /*#__PURE__*/React.createElement(ToastNotificationContext.Provider, {
    value: helper
  }, children, /*#__PURE__*/React.createElement(ToastNotification, {
    notification: latestNotification,
    onDismiss: clear,
    show: !!showNotification,
    onHoverStart: pauseTimer,
    onHoverEnd: resumeTimer
  }), /*#__PURE__*/React.createElement(ToastNotificationList, {
    notifications: notifications,
    groupedCount: countBySeverity,
    show: showNotificationList,
    onDismiss: clear
  }));
};
export default ToastNotificationProvider;
export var useToastNotification = () => useContext(ToastNotificationContext);