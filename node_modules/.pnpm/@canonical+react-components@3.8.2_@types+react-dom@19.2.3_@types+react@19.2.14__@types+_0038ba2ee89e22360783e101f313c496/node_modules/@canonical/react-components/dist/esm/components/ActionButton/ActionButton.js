var _excluded = ["appearance", "children", "className", "disabled", "inline", "loading", "success"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import classNames from "classnames";
import React, { useEffect, useRef, useState } from "react";
import Icon from "../Icon";
export var LOADER_MIN_DURATION = 400; // minimium duration (ms) loader displays
export var SUCCESS_DURATION = 2000; // duration (ms) success tick is displayed

export var Label = /*#__PURE__*/function (Label) {
  Label["WAITING"] = "Waiting for action to complete";
  Label["SUCCESS"] = "Action completed";
  return Label;
}({});
/**
 * This is a not an existing Vanilla component. It can be used to display submitting states for forms or other actions.
 *
 * ActionButton accepts the props from
 * [Button](?path=/docs/components-button--docs) in addition to those in the
 * props table:
 */
var ActionButton = _ref => {
  var {
      appearance,
      children,
      className,
      disabled = null,
      inline = false,
      loading = false,
      success = false
    } = _ref,
    buttonProps = _objectWithoutProperties(_ref, _excluded);
  var [height, setHeight] = useState();
  var [width, setWidth] = useState();
  var [showLoader, setShowLoader] = useState(false);
  var [showSuccess, setShowSuccess] = useState(false);
  var ref = useRef(null);
  var startLoadTime = useRef(undefined);

  // Set up loader timer
  useEffect(() => {
    var loaderTimeout;
    if (loading) {
      // add a condition to prevent double set startLoadTime
      // when showLoader changes.
      if (startLoadTime.current === undefined) {
        // Keep track of the time when loading starts
        startLoadTime.current = new Date();
      }
      // Explicitly set button dimensions
      if (ref.current && !!ref.current.getBoundingClientRect()) {
        setHeight(ref.current.getBoundingClientRect().height);
        setWidth(ref.current.getBoundingClientRect().width);
      }
      setShowLoader(true);
    }
    if (!loading && showLoader) {
      var _startLoadTime$curren;
      var now = new Date();
      // calculate elapsed loading time
      var loadingMilliseconds = now.getTime() - ((_startLoadTime$curren = startLoadTime.current) !== null && _startLoadTime$curren !== void 0 ? _startLoadTime$curren : now).getTime();

      // and subtract it from LOADER_MIN_DURATION,

      // also add an edge case when time diff is less than 0 to be 0.
      var timeoutDuration = Math.max(LOADER_MIN_DURATION - loadingMilliseconds, 0);
      var loadFinishHandler = () => {
        startLoadTime.current = undefined;
        setShowLoader(false);
        if (success) {
          setShowSuccess(true);
        }
      };
      if (timeoutDuration > 0) {
        loaderTimeout = window.setTimeout(loadFinishHandler, timeoutDuration);
      } else {
        loadFinishHandler();
      }
    }
    if (!loading && !showLoader) {
      setHeight(null);
      setWidth(null);
    }
    return () => window.clearTimeout(loaderTimeout);
  }, [loading, showLoader, success]);

  // Set up success timer
  useEffect(() => {
    var successTimeout;
    if (showSuccess) {
      successTimeout = window.setTimeout(() => {
        setHeight(null);
        setWidth(null);
        setShowSuccess(false);
      }, SUCCESS_DURATION);
    }
    return () => window.clearTimeout(successTimeout);
  }, [showSuccess]);
  var buttonClasses = classNames(className, "p-action-button", appearance ? "p-button--".concat(appearance) : "p-button", {
    "is-processing": showLoader || showSuccess,
    "is-disabled": disabled === null ? showLoader : disabled,
    "is-inline": inline
  });
  var showIcon = showLoader || showSuccess;
  var icon = showLoader && "spinner" || showSuccess && "success" || null;
  var iconLight = appearance === "positive" || appearance === "negative";

  // This component uses the base button element instead of the Button component
  // as the button requires a ref and Button would have to be updated to use
  // forwardRef which is not currently supported by components that use
  // typescript generics.
  return /*#__PURE__*/React.createElement("button", _extends({
    className: buttonClasses,
    disabled: disabled === null ? showLoader : disabled,
    ref: ref,
    style: height && width ? {
      height: "".concat(height, "px"),
      width: "".concat(width, "px")
    } : undefined
  }, buttonProps), showIcon ? /*#__PURE__*/React.createElement(Icon, {
    "aria-label": showLoader ? Label.WAITING : Label.SUCCESS,
    className: showLoader ? "u-animation--spin" : null,
    light: iconLight,
    name: icon
  }) : children);
};
export default ActionButton;