var _excluded = ["autoAdjust", "children", "className", "closeOnEsc", "closeOnOutsideClick", "constrainPanelWidth", "dropdownClassName", "dropdownProps", "hasToggleIcon", "links", "onToggleMenu", "position", "positionNode", "scrollOverflow", "toggle", "toggleAppearance", "toggleClassName", "toggleDisabled", "toggleLabel", "toggleLabelFirst", "toggleProps", "visible"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import classNames from "classnames";
import React, { useCallback, useEffect, useId, useRef, useState } from "react";
import { useListener, usePrevious } from "../../hooks";
import Button from "../Button";
import ContextualMenuDropdown from "./ContextualMenuDropdown";
import { usePortal } from "../../external";
export var Label = /*#__PURE__*/function (Label) {
  Label["Toggle"] = "Toggle menu";
  return Label;
}({});

/**
 * The props for the ContextualMenu component.
 * @template L - The type of the link props.
 */

/**
 * Get the node to use for positioning the menu.
 * @param wrapper - The component's wrapping element.
 * @param positionNode - A positioning node, if supplied.
 * @return A node or null.
 */
var getPositionNode = (wrapper, positionNode) => {
  if (positionNode) {
    return positionNode;
  } else if (wrapper) {
    // We want to position the menu in relation to the toggle, if it exists.
    var toggle = wrapper.querySelector(".p-contextual-menu__toggle");
    return toggle || wrapper;
  }
  return null;
};

/**
 * Whether the positioning node is visible.
 * @param positionNode - The node that is used to position the menu.
 * @return Whether the positioning node is visible.
 */
var getPositionNodeVisible = positionNode => {
  return !positionNode || positionNode.offsetParent !== null;
};

/**
 * This is a [React](https://reactjs.org/) component for the Vanilla [Contextual menu](https://docs.vanillaframework.io/patterns//contextual-menu/).
 *
 * A contextual menu can be used in conjunction with any page element to provide a contextual menu.
 */
var ContextualMenu = _ref => {
  var {
      autoAdjust = true,
      children,
      className,
      closeOnEsc = true,
      closeOnOutsideClick = true,
      constrainPanelWidth,
      dropdownClassName,
      dropdownProps,
      hasToggleIcon,
      links,
      onToggleMenu,
      position = "right",
      positionNode,
      scrollOverflow,
      toggle,
      toggleAppearance,
      toggleClassName,
      toggleDisabled,
      toggleLabel,
      toggleLabelFirst = true,
      toggleProps,
      visible = false
    } = _ref,
    wrapperProps = _objectWithoutProperties(_ref, _excluded);
  var id = useId();
  var wrapper = useRef(null);
  var [positionCoords, setPositionCoords] = useState();
  var [adjustedPosition, setAdjustedPosition] = useState(position);
  useEffect(() => {
    setAdjustedPosition(position);
  }, [position, autoAdjust]);

  // Update the coordinates of the position node.
  var updatePositionCoords = useCallback(() => {
    var parent = getPositionNode(wrapper.current, positionNode);
    if (!parent) {
      return;
    }
    setPositionCoords(parent.getBoundingClientRect());
  }, [wrapper, positionNode]);
  var {
    openPortal,
    closePortal,
    isOpen,
    Portal
  } = usePortal({
    closeOnEsc,
    closeOnOutsideClick,
    isOpen: visible,
    onOpen: () => {
      // Call the toggle callback, if supplied.
      onToggleMenu === null || onToggleMenu === void 0 || onToggleMenu(true);
      // When the menu opens then update the coordinates of the parent.
      updatePositionCoords();
    },
    onClose: () => {
      // Call the toggle callback, if supplied.
      onToggleMenu === null || onToggleMenu === void 0 || onToggleMenu(false);
    },
    programmaticallyOpen: true
  });
  var previousVisible = usePrevious(visible);
  var labelNode = toggleLabel && typeof toggleLabel === "string" ? /*#__PURE__*/React.createElement("span", null, toggleLabel) : /*#__PURE__*/React.isValidElement(toggleLabel) ? toggleLabel : null;
  var contextualMenuClassName = classNames(className, "p-contextual-menu", {
    ["p-contextual-menu--".concat(adjustedPosition)]: adjustedPosition !== "right"
  });

  // Update the coordinates of the wrapper once it mounts to the dom. This uses
  // The callback ref pattern:
  // https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
  var wrapperRef = useCallback(node => {
    wrapper.current = node;
    if (node !== null) {
      updatePositionCoords();
    }
  }, [updatePositionCoords]);

  // Handle controlling updates to the menu visibility from outside
  // the component.
  useEffect(() => {
    if (visible !== previousVisible) {
      if (visible && !isOpen) {
        openPortal();
      } else if (!visible && isOpen) {
        closePortal();
      }
    }
  }, [closePortal, openPortal, visible, isOpen, previousVisible]);
  var onResize = useCallback(() => {
    var parent = getPositionNode(wrapper.current, positionNode);
    if (parent && !getPositionNodeVisible(parent)) {
      // Hide the menu if the item has become hidden. This might happen in
      // a responsive table when columns become hidden as the page
      // becomes smaller.
      closePortal();
    } else {
      // Only update if the coordinates have changed.
      // The check fixes a bug with chrome, where an input receiving focus and
      // opening the keyboard causes a resize and the keyboard closes right after
      // opening.
      var coords = parent.getBoundingClientRect();
      if (JSON.stringify(coords) !== JSON.stringify(positionCoords)) {
        // Update the coordinates so that the menu stays relative to the
        // toggle button.
        updatePositionCoords();
      }
    }
  }, [closePortal, positionNode, positionCoords, updatePositionCoords]);
  var onScroll = useCallback(e => {
    var parent = getPositionNode(wrapper.current, positionNode);
    // update position if the scroll event is triggered by the parent of the menu
    if (parent && e.target.contains(parent)) {
      // Update the coordinates so that the menu stays relative to the
      // toggle button.
      updatePositionCoords();
    }
  }, [positionNode, updatePositionCoords]);
  useListener(window, onResize, "resize", true, isOpen);
  useListener(window, onScroll, "scroll", false, isOpen, true);
  var toggleNode = null;
  if (toggle) {
    toggleNode = toggle;
  } else if (hasToggleIcon || toggleLabel) {
    toggleNode = /*#__PURE__*/React.createElement(Button, _extends({
      appearance: toggleAppearance,
      "aria-controls": id,
      "aria-expanded": isOpen ? "true" : "false",
      "aria-label": toggleLabel ? null : Label.Toggle,
      "aria-pressed": isOpen ? "true" : "false",
      "aria-haspopup": "true",
      className: classNames("p-contextual-menu__toggle", toggleClassName),
      disabled: toggleDisabled,
      hasIcon: hasToggleIcon,
      onClick: evt => {
        if (!isOpen) {
          openPortal(evt);
        } else {
          closePortal(evt);
        }
      },
      type: "button"
    }, toggleProps), toggleLabelFirst ? labelNode : null, hasToggleIcon ? /*#__PURE__*/React.createElement("i", {
      className: classNames("p-icon--chevron-down p-contextual-menu__indicator", {
        "is-light": ["negative", "positive"].includes(toggleAppearance)
      })
    }) : null, toggleLabelFirst ? null : labelNode);
  }
  return /*#__PURE__*/React.createElement("span", _extends({
    className: contextualMenuClassName,
    ref: wrapperRef
  }, wrapperProps), toggleNode, isOpen && /*#__PURE__*/React.createElement(Portal, null, /*#__PURE__*/React.createElement(ContextualMenuDropdown, _extends({
    adjustedPosition: adjustedPosition,
    autoAdjust: autoAdjust,
    handleClose: closePortal,
    constrainPanelWidth: constrainPanelWidth,
    dropdownClassName: dropdownClassName,
    dropdownContent: children,
    id: id,
    isOpen: isOpen,
    links: links,
    position: position,
    positionCoords: positionCoords,
    contextualMenuClassName: contextualMenuClassName,
    positionNode: getPositionNode(wrapper.current),
    scrollOverflow: scrollOverflow,
    setAdjustedPosition: setAdjustedPosition
  }, dropdownProps))));
};
export default ContextualMenu;