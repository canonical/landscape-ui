import _pt from "prop-types";
import React, { useEffect, useLayoutEffect, useRef, useState } from "react";
import classnames from "classnames";
import { useListener } from "../../../hooks";
import SearchBox from "../../SearchBox";
var DROPDOWN_MAX_HEIGHT = 16 * 30; // 30rem with base 16px
var DROPDOWN_MARGIN = 20;
export var adjustDropdownHeightBelow = dropdown => {
  var _window$visualViewpor;
  var dropdownRect = dropdown.getBoundingClientRect();
  var dropdownHeight = dropdown.offsetHeight;
  var viewportHeight = ((_window$visualViewpor = window.visualViewport) === null || _window$visualViewpor === void 0 ? void 0 : _window$visualViewpor.height) || window.innerHeight;

  // If the dropdown is cut off at the bottom of the viewport
  // adjust the height to fit within the viewport minus fixed margin.
  // This usually becomes an issue when the dropdown is at the bottom of the viewport or screen getting smaller.
  if (dropdownRect.bottom >= viewportHeight) {
    var _adjustedHeight = dropdownHeight - dropdownRect.bottom + viewportHeight - DROPDOWN_MARGIN;
    dropdown.style.height = "".concat(_adjustedHeight, "px");
    dropdown.style.maxHeight = "".concat(_adjustedHeight, "px");
    return;
  }

  // If the dropdown does not have overflow, the dropdown should fit its content.
  var hasOverflow = dropdown.scrollHeight > dropdown.clientHeight;
  if (!hasOverflow) {
    dropdown.style.height = "auto";
    dropdown.style.maxHeight = "";
    return;
  }

  // If the dropdown is not cut off at the bottom of the viewport
  // adjust the height of the dropdown so that its bottom edge is 20px from the bottom of the viewport
  // until the dropdown max height is reached.
  var adjustedHeight = Math.min(viewportHeight - dropdownRect.top - DROPDOWN_MARGIN, DROPDOWN_MAX_HEIGHT);
  dropdown.style.height = "".concat(adjustedHeight, "px");
  dropdown.style.maxHeight = "".concat(adjustedHeight, "px");
};
export var adjustDropdownHeightAbove = (dropdown, search) => {
  // The search height is subtracted (if necessary) so that no options will be hidden behind the search input.
  var searchRect = search === null || search === void 0 ? void 0 : search.getBoundingClientRect();
  var searchHeight = (searchRect === null || searchRect === void 0 ? void 0 : searchRect.height) || 0;
  var dropdownRect = dropdown.getBoundingClientRect();

  // If the dropdown does not have overflow, do not adjust.
  var hasOverflow = dropdown.scrollHeight > dropdown.clientHeight;
  if (!hasOverflow) {
    dropdown.style.height = "auto";
    dropdown.style.maxHeight = "";
    return;
  }

  // adjust the height of the dropdown so that its top edge is 20px from the top of the viewport.
  // until the dropdown max height is reached.
  // unlike the case where the dropdown is bellow the toggle, dropdown.bottom represents the available space above the toggle always.
  // this makes the calculation simpler since we only need to work with dropdown.bottom regardless if the element is cut off or not.
  var adjustedHeight = Math.min(dropdownRect.bottom - searchHeight - DROPDOWN_MARGIN, DROPDOWN_MAX_HEIGHT);
  dropdown.style.height = "".concat(adjustedHeight, "px");
  dropdown.style.maxHeight = "".concat(adjustedHeight, "px");
};
export var dropdownIsAbove = dropdown => {
  var toggle = document.querySelector(".p-custom-select__toggle");
  var dropdownRect = dropdown.getBoundingClientRect();
  var toggleRect = toggle.getBoundingClientRect();
  return toggleRect.top >= dropdownRect.bottom;
};
export var adjustDropdownHeight = (dropdown, search) => {
  if (!dropdown) {
    return;
  }
  if (dropdownIsAbove(dropdown)) {
    adjustDropdownHeightAbove(dropdown, search);
    return;
  }
  adjustDropdownHeightBelow(dropdown);
};
export var getOptionText = option => {
  if (option.text) {
    return option.text;
  }
  if (typeof option.label === "string") {
    return option.label;
  }
  throw new Error("CustomSelect: options must have a string label or a text property");
};
var getIsSearchable = (searchable, numberOfOptions) => {
  if (searchable === "async") {
    return true;
  }
  if (searchable === "never") {
    return false;
  }
  if (numberOfOptions <= 1) {
    return false;
  }
  if (searchable === "always") {
    return true;
  }
  if (searchable === "auto" && numberOfOptions >= 5) {
    return true;
  }
  return false;
};
var CustomSelectDropdown = _ref => {
  var {
    searchable,
    searchPlaceholder,
    name,
    options,
    onSelect,
    onSearch,
    onClose,
    header,
    toggleId
  } = _ref;
  var [search, setSearch] = useState("");
  // track highlighted option index for keyboard actions
  var [highlightedOptionIndex, setHighlightedOptionIndex] = useState(0);
  // use ref to keep a reference to all option HTML elements so we do not need to make DOM calls later for scrolling
  var optionsRef = useRef([]);
  var dropdownRef = useRef(null);
  var searchRef = useRef(null);
  var dropdownListRef = useRef(null);
  var isSearchable = getIsSearchable(searchable, options.length);
  useEffect(() => {
    if (dropdownRef.current) {
      var _toggle$getBoundingCl, _toggle$getBoundingCl2;
      var toggle = document.getElementById(toggleId);

      // align width with wrapper toggle width
      var toggleWidth = (_toggle$getBoundingCl = toggle === null || toggle === void 0 || (_toggle$getBoundingCl2 = toggle.getBoundingClientRect()) === null || _toggle$getBoundingCl2 === void 0 ? void 0 : _toggle$getBoundingCl2.width) !== null && _toggle$getBoundingCl !== void 0 ? _toggle$getBoundingCl : 0;
      dropdownRef.current.style.setProperty("min-width", "".concat(toggleWidth, "px"));
    }
    setTimeout(() => {
      var _dropdownRef$current;
      if (isSearchable) {
        var _searchRef$current;
        (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.focus();
        return;
      }
      (_dropdownRef$current = dropdownRef.current) === null || _dropdownRef$current === void 0 || _dropdownRef$current.focus();
    }, 100);
  }, [isSearchable, toggleId]);
  var handleResize = () => {
    adjustDropdownHeight(dropdownListRef.current, searchRef.current);
  };
  useLayoutEffect(handleResize, []);
  useListener(window, handleResize, "resize");

  // track selected index from key board action and scroll into view if needed
  useEffect(() => {
    var _optionsRef$current$h;
    (_optionsRef$current$h = optionsRef.current[highlightedOptionIndex]) === null || _optionsRef$current$h === void 0 || _optionsRef$current$h.scrollIntoView({
      block: "nearest",
      inline: "nearest"
    });
  }, [highlightedOptionIndex]);
  var filteredOptions = onSearch ? options : options === null || options === void 0 ? void 0 : options.filter(option => {
    if (!search || option.disabled) return true;
    var searchText = getOptionText(option) || option.value;
    return searchText.toLowerCase().includes(search);
  });
  var getNextOptionIndex = (goingUp, prevIndex) => {
    var increment = goingUp ? -1 : 1;
    var currIndex = prevIndex + increment;
    // skip disabled options for key board action
    while (filteredOptions[currIndex] && (_filteredOptions$curr = filteredOptions[currIndex]) !== null && _filteredOptions$curr !== void 0 && _filteredOptions$curr.disabled) {
      var _filteredOptions$curr;
      currIndex += increment;
    }

    // consider upper bound for navigating down the list
    if (increment > 0) {
      return currIndex < filteredOptions.length ? currIndex : prevIndex;
    }

    // consider lower bound for navigating up the list
    return currIndex >= 0 ? currIndex : prevIndex;
  };

  // handle keyboard actions for navigating the select dropdown
  var handleKeyDown = event => {
    var upDownKeys = ["ArrowUp", "ArrowDown"];

    // prevent default browser actions for up, down, enter and escape keys
    // also prevent any other event listeners from being called up the DOM tree
    if ([...upDownKeys, "Enter", "Escape", "Tab"].includes(event.key)) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation();
    }
    if (upDownKeys.includes(event.key)) {
      setHighlightedOptionIndex(prevIndex => {
        var goingUp = event.key === "ArrowUp";
        return getNextOptionIndex(goingUp, prevIndex);
      });
    }
    if (event.key === "Enter" && filteredOptions[highlightedOptionIndex]) {
      onSelect(filteredOptions[highlightedOptionIndex].value);
    }
    if (event.key === "Escape" || event.key === "Tab") {
      onClose();
    }
  };
  var handleSearch = value => {
    setSearch(value.toLowerCase());
    // reset selected index when search text changes
    setHighlightedOptionIndex(0);
    optionsRef.current = [];
    if (onSearch) {
      onSearch(value);
    }
  };
  var handleSelect = option => {
    if (option.disabled) {
      return;
    }
    onSelect(option.value);
  };
  var optionItems = filteredOptions.map((option, idx) => {
    return /*#__PURE__*/React.createElement("li", {
      key: "".concat(option.value, "-").concat(idx),
      onClick: () => handleSelect(option),
      className: classnames("p-list__item", "p-custom-select__option", "u-truncate", {
        disabled: option.disabled,
        highlight: idx === highlightedOptionIndex && !option.disabled
      })
      // adding option elements to a ref array makes it easier to scroll the element later
      // else we'd have to make a DOM call to find the element based on some identifier
      ,
      ref: el => {
        if (!el) return;
        optionsRef.current[idx] = el;
      },
      role: "option",
      onMouseMove: () => setHighlightedOptionIndex(idx)
    }, /*#__PURE__*/React.createElement("span", {
      className: classnames({
        "u-text--muted": option.disabled
      })
    }, option.label));
  });
  return /*#__PURE__*/React.createElement("div", {
    className: "p-custom-select__dropdown u-no-padding",
    role: "combobox",
    onKeyDownCapture: handleKeyDown
    // allow focus on the dropdown so that keyboard actions can be captured
    ,
    tabIndex: -1,
    ref: dropdownRef,
    onMouseDown: e => {
      // when custom select is used in a modal, which is a portal, a dropdown click
      // should not close the modal itself, so we stop the event right here.
      e.stopPropagation();
    }
  }, isSearchable && /*#__PURE__*/React.createElement("div", {
    className: "p-custom-select__search u-no-padding--bottom"
  }, /*#__PURE__*/React.createElement(SearchBox, {
    ref: searchRef,
    id: "select-search-".concat(name),
    name: "select-search-".concat(name),
    type: "text",
    "aria-label": "Search for ".concat(name),
    placeholder: searchPlaceholder,
    className: "u-no-margin--bottom",
    onChange: handleSearch,
    value: search,
    autocomplete: "off"
  })), header, /*#__PURE__*/React.createElement("ul", {
    className: "p-list u-no-margin--bottom",
    role: "listbox",
    ref: dropdownListRef
  }, optionItems));
};
CustomSelectDropdown.propTypes = {
  searchable: _pt.oneOf(["auto", "always", "async", "never"]),
  searchPlaceholder: _pt.string,
  name: _pt.string.isRequired,
  options: _pt.array.isRequired,
  onSelect: _pt.func.isRequired,
  onSearch: _pt.func,
  onClose: _pt.func.isRequired,
  header: _pt.node,
  toggleId: _pt.string.isRequired
};
export default CustomSelectDropdown;