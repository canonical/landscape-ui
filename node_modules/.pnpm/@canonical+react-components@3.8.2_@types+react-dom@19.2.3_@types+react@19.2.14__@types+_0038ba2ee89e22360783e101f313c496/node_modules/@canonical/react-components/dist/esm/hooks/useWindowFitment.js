import { useCallback, useEffect, useRef } from "react";
import { useListener } from "./useListener";
/**
 * A hook to determine if an element fits on the window.
 * @param targetNode The element to try and fit on the window.
 * @param referenceNode The element to use to position the target.
 * @param callback The function to call when updating fitment info.
 * @param spacer An additional space to leave between the target and reference.
 * @param shouldCheck Whether the fitment info should be being checked.
 * @param fromMouse Whether the target should be being positioned in relation
 *                  to the mouse. In this case refernceNode will be used to
 *                  listen for mouseover events.
 */
export var useWindowFitment = function useWindowFitment(targetNode, referenceNode, callback) {
  var spacer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var shouldCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var fromMouse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var htmlRef = useRef(document.querySelector("html"));
  var update = useCallback(evt => {
    var referenceCoordinates;
    if (fromMouse) {
      if (evt) {
        referenceCoordinates = {
          // The mouse is a single point so use 0 for the height and width.
          height: 0,
          left: ("x" in evt && typeof evt.x === "number" ? evt.x : null) || 0,
          top: ("y" in evt && typeof evt.y === "number" ? evt.y : null) || 0,
          width: 0
        };
      }
    } else if (referenceNode) {
      referenceCoordinates = referenceNode.getBoundingClientRect();
    }
    if (shouldCheck && targetNode && referenceCoordinates) {
      var {
        height: targetHeight,
        width: targetWidth
      } = targetNode.getBoundingClientRect();
      var {
        height: referenceHeight,
        left: referenceLeft,
        top: referenceTop,
        width: referenceWidth
      } = referenceCoordinates;
      var referenceBottom = referenceTop + referenceHeight;
      var referenceRight = referenceLeft + referenceWidth;
      var referenceCenterX = referenceLeft + referenceWidth / 2;
      var referenceCenterY = referenceTop + referenceHeight / 2;
      var windowLeft = htmlRef.current.scrollLeft;
      var windowRight = window.innerWidth - htmlRef.current.scrollLeft;
      var windowTop = 0;
      var windowBottom = window.innerHeight;
      var heightIncludingSpace = targetHeight + spacer;
      var widthIncludingSpace = targetWidth + spacer;
      var widthFromCenter = targetWidth / 2;
      var heightFromCenter = targetHeight / 2;
      callback({
        fromTop: {
          fitsAbove: referenceTop - heightIncludingSpace > windowTop,
          fitsBelow: referenceTop + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceTop),
          spaceBelow: windowBottom - referenceTop
        },
        fromBottom: {
          fitsAbove: referenceBottom - heightIncludingSpace > windowTop,
          fitsBelow: referenceBottom + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceBottom),
          spaceBelow: windowBottom - referenceBottom
        },
        fromLeft: {
          fitsLeft: referenceLeft - widthIncludingSpace > windowLeft,
          fitsRight: referenceLeft + widthIncludingSpace < windowRight,
          spaceLeft: Math.abs(windowLeft - referenceLeft),
          spaceRight: windowRight - referenceLeft
        },
        fromRight: {
          fitsLeft: referenceRight - widthIncludingSpace > windowLeft,
          fitsRight: referenceRight + widthIncludingSpace < windowRight,
          spaceLeft: Math.abs(windowLeft - referenceRight),
          spaceRight: windowRight - referenceRight
        },
        fromCenter: {
          fitsLeft: referenceCenterX - widthIncludingSpace > windowLeft,
          fitsRight: referenceCenterX + widthIncludingSpace < windowRight,
          fitsAbove: referenceCenterY - heightIncludingSpace > windowTop,
          fitsBelow: referenceCenterY + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceCenterY),
          spaceBelow: windowBottom - referenceCenterY,
          spaceLeft: Math.abs(windowLeft - referenceCenterX),
          spaceRight: windowRight - referenceCenterX,
          fitsCentered: {
            fitsLeft: referenceCenterX - widthFromCenter > windowLeft,
            fitsRight: referenceCenterX + widthFromCenter < windowRight,
            fitsAbove: referenceCenterY - heightFromCenter > windowTop,
            fitsBelow: referenceCenterY + heightFromCenter < windowBottom
          }
        }
      });
    }
  }, [shouldCheck, targetNode, callback, spacer, fromMouse, referenceNode]);
  useListener(window, update, "resize", true, shouldCheck && !fromMouse);
  useListener(window, update, "scroll", true, shouldCheck && !fromMouse);
  useListener(referenceNode, update, "mousemove", true, fromMouse && shouldCheck);
  useEffect(() => {
    if (!fromMouse) {
      update();
    }
  }, [fromMouse, update]);
};