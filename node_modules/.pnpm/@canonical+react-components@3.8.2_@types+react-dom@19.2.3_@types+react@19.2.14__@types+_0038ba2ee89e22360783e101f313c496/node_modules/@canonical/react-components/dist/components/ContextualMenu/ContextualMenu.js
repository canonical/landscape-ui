"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Label = void 0;
var _classnames = _interopRequireDefault(require("classnames"));
var _react = _interopRequireWildcard(require("react"));
var _hooks = require("../../hooks");
var _Button = _interopRequireDefault(require("../Button"));
var _ContextualMenuDropdown = _interopRequireDefault(require("./ContextualMenuDropdown"));
var _external = require("../../external");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
let Label = exports.Label = /*#__PURE__*/function (Label) {
  Label["Toggle"] = "Toggle menu";
  return Label;
}({});
/**
 * The props for the ContextualMenu component.
 * @template L - The type of the link props.
 */
/**
 * Get the node to use for positioning the menu.
 * @param wrapper - The component's wrapping element.
 * @param positionNode - A positioning node, if supplied.
 * @return A node or null.
 */
const getPositionNode = (wrapper, positionNode) => {
  if (positionNode) {
    return positionNode;
  } else if (wrapper) {
    // We want to position the menu in relation to the toggle, if it exists.
    const toggle = wrapper.querySelector(".p-contextual-menu__toggle");
    return toggle || wrapper;
  }
  return null;
};

/**
 * Whether the positioning node is visible.
 * @param positionNode - The node that is used to position the menu.
 * @return Whether the positioning node is visible.
 */
const getPositionNodeVisible = positionNode => {
  return !positionNode || positionNode.offsetParent !== null;
};

/**
 * This is a [React](https://reactjs.org/) component for the Vanilla [Contextual menu](https://docs.vanillaframework.io/patterns//contextual-menu/).
 *
 * A contextual menu can be used in conjunction with any page element to provide a contextual menu.
 */
const ContextualMenu = _ref => {
  let {
    autoAdjust = true,
    children,
    className,
    closeOnEsc = true,
    closeOnOutsideClick = true,
    constrainPanelWidth,
    dropdownClassName,
    dropdownProps,
    hasToggleIcon,
    links,
    onToggleMenu,
    position = "right",
    positionNode,
    scrollOverflow,
    toggle,
    toggleAppearance,
    toggleClassName,
    toggleDisabled,
    toggleLabel,
    toggleLabelFirst = true,
    toggleProps,
    visible = false,
    ...wrapperProps
  } = _ref;
  const id = (0, _react.useId)();
  const wrapper = (0, _react.useRef)(null);
  const [positionCoords, setPositionCoords] = (0, _react.useState)();
  const [adjustedPosition, setAdjustedPosition] = (0, _react.useState)(position);
  (0, _react.useEffect)(() => {
    setAdjustedPosition(position);
  }, [position, autoAdjust]);

  // Update the coordinates of the position node.
  const updatePositionCoords = (0, _react.useCallback)(() => {
    const parent = getPositionNode(wrapper.current, positionNode);
    if (!parent) {
      return;
    }
    setPositionCoords(parent.getBoundingClientRect());
  }, [wrapper, positionNode]);
  const {
    openPortal,
    closePortal,
    isOpen,
    Portal
  } = (0, _external.usePortal)({
    closeOnEsc,
    closeOnOutsideClick,
    isOpen: visible,
    onOpen: () => {
      // Call the toggle callback, if supplied.
      onToggleMenu === null || onToggleMenu === void 0 || onToggleMenu(true);
      // When the menu opens then update the coordinates of the parent.
      updatePositionCoords();
    },
    onClose: () => {
      // Call the toggle callback, if supplied.
      onToggleMenu === null || onToggleMenu === void 0 || onToggleMenu(false);
    },
    programmaticallyOpen: true
  });
  const previousVisible = (0, _hooks.usePrevious)(visible);
  const labelNode = toggleLabel && typeof toggleLabel === "string" ? /*#__PURE__*/_react.default.createElement("span", null, toggleLabel) : /*#__PURE__*/_react.default.isValidElement(toggleLabel) ? toggleLabel : null;
  const contextualMenuClassName = (0, _classnames.default)(className, "p-contextual-menu", {
    ["p-contextual-menu--".concat(adjustedPosition)]: adjustedPosition !== "right"
  });

  // Update the coordinates of the wrapper once it mounts to the dom. This uses
  // The callback ref pattern:
  // https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
  const wrapperRef = (0, _react.useCallback)(node => {
    wrapper.current = node;
    if (node !== null) {
      updatePositionCoords();
    }
  }, [updatePositionCoords]);

  // Handle controlling updates to the menu visibility from outside
  // the component.
  (0, _react.useEffect)(() => {
    if (visible !== previousVisible) {
      if (visible && !isOpen) {
        openPortal();
      } else if (!visible && isOpen) {
        closePortal();
      }
    }
  }, [closePortal, openPortal, visible, isOpen, previousVisible]);
  const onResize = (0, _react.useCallback)(() => {
    const parent = getPositionNode(wrapper.current, positionNode);
    if (parent && !getPositionNodeVisible(parent)) {
      // Hide the menu if the item has become hidden. This might happen in
      // a responsive table when columns become hidden as the page
      // becomes smaller.
      closePortal();
    } else {
      // Only update if the coordinates have changed.
      // The check fixes a bug with chrome, where an input receiving focus and
      // opening the keyboard causes a resize and the keyboard closes right after
      // opening.
      const coords = parent.getBoundingClientRect();
      if (JSON.stringify(coords) !== JSON.stringify(positionCoords)) {
        // Update the coordinates so that the menu stays relative to the
        // toggle button.
        updatePositionCoords();
      }
    }
  }, [closePortal, positionNode, positionCoords, updatePositionCoords]);
  const onScroll = (0, _react.useCallback)(e => {
    const parent = getPositionNode(wrapper.current, positionNode);
    // update position if the scroll event is triggered by the parent of the menu
    if (parent && e.target.contains(parent)) {
      // Update the coordinates so that the menu stays relative to the
      // toggle button.
      updatePositionCoords();
    }
  }, [positionNode, updatePositionCoords]);
  (0, _hooks.useListener)(window, onResize, "resize", true, isOpen);
  (0, _hooks.useListener)(window, onScroll, "scroll", false, isOpen, true);
  let toggleNode = null;
  if (toggle) {
    toggleNode = toggle;
  } else if (hasToggleIcon || toggleLabel) {
    toggleNode = /*#__PURE__*/_react.default.createElement(_Button.default, _extends({
      appearance: toggleAppearance,
      "aria-controls": id,
      "aria-expanded": isOpen ? "true" : "false",
      "aria-label": toggleLabel ? null : Label.Toggle,
      "aria-pressed": isOpen ? "true" : "false",
      "aria-haspopup": "true",
      className: (0, _classnames.default)("p-contextual-menu__toggle", toggleClassName),
      disabled: toggleDisabled,
      hasIcon: hasToggleIcon,
      onClick: evt => {
        if (!isOpen) {
          openPortal(evt);
        } else {
          closePortal(evt);
        }
      },
      type: "button"
    }, toggleProps), toggleLabelFirst ? labelNode : null, hasToggleIcon ? /*#__PURE__*/_react.default.createElement("i", {
      className: (0, _classnames.default)("p-icon--chevron-down p-contextual-menu__indicator", {
        "is-light": ["negative", "positive"].includes(toggleAppearance)
      })
    }) : null, toggleLabelFirst ? null : labelNode);
  }
  return /*#__PURE__*/_react.default.createElement("span", _extends({
    className: contextualMenuClassName,
    ref: wrapperRef
  }, wrapperProps), toggleNode, isOpen && /*#__PURE__*/_react.default.createElement(Portal, null, /*#__PURE__*/_react.default.createElement(_ContextualMenuDropdown.default, _extends({
    adjustedPosition: adjustedPosition,
    autoAdjust: autoAdjust,
    handleClose: closePortal,
    constrainPanelWidth: constrainPanelWidth,
    dropdownClassName: dropdownClassName,
    dropdownContent: children,
    id: id,
    isOpen: isOpen,
    links: links,
    position: position,
    positionCoords: positionCoords,
    contextualMenuClassName: contextualMenuClassName,
    positionNode: getPositionNode(wrapper.current),
    scrollOverflow: scrollOverflow,
    setAdjustedPosition: setAdjustedPosition
  }, dropdownProps))));
};
var _default = exports.default = ContextualMenu;