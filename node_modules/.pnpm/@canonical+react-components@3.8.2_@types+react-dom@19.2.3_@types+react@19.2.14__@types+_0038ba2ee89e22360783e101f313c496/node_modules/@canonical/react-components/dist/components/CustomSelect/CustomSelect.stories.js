"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.StandardOptions = exports.ManualSearchable = exports.DisabledOptions = exports.CustomOptionsAndSelectedLabel = exports.CustomOptions = exports.AutoSearchable = exports.AsyncSearchable = void 0;
var _CustomSelect = _interopRequireDefault(require("./CustomSelect"));
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const generateStandardOptions = num => Array(num).fill(null).map((_, i) => ({
  value: "option-".concat(i + 1),
  label: "Option ".concat(i + 1),
  text: "Option ".concat(i + 1),
  disabled: false
}));
const generateCustomOptions = () => {
  return [{
    value: "smile",
    label: /*#__PURE__*/_react.default.createElement("div", null, "\uD83D\uDE00"),
    text: "Smile",
    disabled: false
  }, {
    value: "grin",
    label: /*#__PURE__*/_react.default.createElement("div", null, "\uD83D\uDE01"),
    text: "Grin",
    disabled: false
  }, {
    value: "cry",
    label: /*#__PURE__*/_react.default.createElement("div", null, "\uD83D\uDE2D"),
    text: "Cry",
    disabled: false
  }, {
    value: "angry",
    label: /*#__PURE__*/_react.default.createElement("div", null, "\uD83D\uDE21"),
    text: "Angry",
    disabled: false
  }, {
    value: "sad",
    label: /*#__PURE__*/_react.default.createElement("div", null, "\uD83D\uDE22"),
    text: "Sad",
    disabled: false
  }];
};
const generateCustomOptionsWithSelectedLabel = () => {
  const options = [{
    type: "ovn",
    name: "ovntest",
    config: {
      "security.acls": "foo,bar"
    }
  }, {
    type: "bridge",
    name: "lxdbr0",
    config: {}
  }, {
    type: "bridge",
    name: "microbr0",
    config: {}
  }, {
    type: "macvlan",
    name: "macvlantest",
    config: {}
  }].map(network => {
    var _network$config$secur;
    return {
      label: /*#__PURE__*/_react.default.createElement("div", {
        className: "label",
        style: {
          display: "flex",
          gap: "5px"
        }
      }, /*#__PURE__*/_react.default.createElement("span", {
        title: network.name,
        className: "network-option u-truncate",
        style: {
          width: "12rem"
        }
      }, network.name), /*#__PURE__*/_react.default.createElement("span", {
        title: network.type,
        className: "network-option u-truncate",
        style: {
          width: "8rem"
        }
      }, network.type), /*#__PURE__*/_react.default.createElement("span", {
        title: "network ACLs",
        className: "network-option u-truncate u-align--right",
        style: {
          paddingRight: "8px",
          width: "4rem"
        }
      }, ((_network$config$secur = network.config["security.acls"]) === null || _network$config$secur === void 0 ? void 0 : _network$config$secur.length) || "-")),
      value: network.name,
      text: "".concat(network.name, " - ").concat(network.type),
      disabled: false,
      selectedLabel: /*#__PURE__*/_react.default.createElement("span", null, network.name, "\xA0", /*#__PURE__*/_react.default.createElement("span", {
        className: "u-text--muted"
      }, "(", network.type, ")"))
    };
  });
  return options;
};
const getHeader = () => {
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "header",
    style: {
      backgroundColor: "$colors--theme--background-alt",
      display: "flex",
      gap: "$sph--small",
      padding: "$sph--x-small $sph--small",
      position: "sticky",
      top: 0
    }
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "network-option u-no-margin--bottom",
    style: {
      color: "$colors--theme--text-default",
      width: "12rem"
    }
  }, "Name"), /*#__PURE__*/_react.default.createElement("span", {
    className: "network-option u-no-margin--bottom",
    style: {
      color: "$colors--theme--text-default",
      width: "8rem"
    }
  }, "Type"), /*#__PURE__*/_react.default.createElement("span", {
    className: "network-option u-no-margin--bottom",
    style: {
      color: "$colors--theme--text-default",
      width: "4rem"
    }
  }, "ACLs"));
};
const Template = _ref => {
  let {
    ...props
  } = _ref;
  const [selected, setSelected] = (0, _react.useState)(props.value || "");
  return /*#__PURE__*/_react.default.createElement(_CustomSelect.default, _extends({}, props, {
    value: selected,
    onChange: value => setSelected(value)
  }));
};
const meta = {
  component: _CustomSelect.default,
  render: Template,
  tags: ["autodocs"],
  args: {
    name: "customSelect",
    label: "Custom Select",
    defaultToggleLabel: "Select an option",
    searchable: "auto",
    searchPlaceholder: "Search",
    initialPosition: "left"
  },
  argTypes: {
    searchable: {
      options: ["auto", "always", "async", "never"],
      control: {
        type: "select"
      }
    },
    initialPosition: {
      options: ["left", "right"],
      control: {
        type: "select"
      }
    }
  }
};
var _default = exports.default = meta;
/**
 * If `label` is of `string` type. You do not have to do anything extra to render it.
 */
const StandardOptions = exports.StandardOptions = {
  args: {
    options: generateStandardOptions(10)
  }
};

/**
 * If `label` is of `ReactNode` type. You can render custom content.
 * In this case, the `text` property for each option is required and is used for display in the toggle, search and sort functionalities.
 */
const CustomOptions = exports.CustomOptions = {
  args: {
    options: generateCustomOptions()
  }
};

/**
 * If `label` is of `ReactNode` type. You can render custom content.
 * In this case, the `selectedLabel` for each option is provided and will be displayed in the toggle instead of `text`
 * The `text` property for each option is still required and is used for search and sort functionalities.
 */
const CustomOptionsAndSelectedLabel = exports.CustomOptionsAndSelectedLabel = {
  args: {
    options: generateCustomOptionsWithSelectedLabel(),
    header: getHeader(),
    dropdownClassName: "network-select-dropdown"
  }
};

/**
 * For each option, if `disabled` is set to `true`, the option will be disabled.
 */
const DisabledOptions = exports.DisabledOptions = {
  args: {
    options: generateStandardOptions(5).map((option, i) => ({
      ...option,
      disabled: i % 2 === 0
    }))
  }
};

/**
 * Search is enabled by default when there are 5 or more options.
 */
const AutoSearchable = exports.AutoSearchable = {
  args: {
    options: generateStandardOptions(5),
    searchable: "auto"
  }
};

/**
 * Search can be enabled manually by setting `searchable` to `always`.
 */
const ManualSearchable = exports.ManualSearchable = {
  args: {
    options: generateStandardOptions(4),
    searchable: "always"
  }
};

/**
 * Search can be enabled manually by setting `searchable` to `async`.
 * This will always show the search input regardless of the number of options.
 */
const AsyncSearchable = exports.AsyncSearchable = {
  args: {
    options: generateStandardOptions(0),
    searchable: "async"
  }
};