"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MultiSelectDropdown = exports.MultiSelect = void 0;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _classnames = _interopRequireDefault(require("classnames"));
var _react = _interopRequireWildcard(require("react"));
require("./MultiSelect.scss");
var _index = require("../../index");
var _FadeInDown = require("./FadeInDown");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const sortAlphabetically = (a, b) => {
  return a.label.localeCompare(b.label, "en", {
    numeric: true
  });
};
const createSortSelectedItems = previouslySelectedItemValues => (a, b) => {
  if (previouslySelectedItemValues) {
    const aIsPreviouslySelected = previouslySelectedItemValues.has(a.value);
    const bIsPreviouslySelected = previouslySelectedItemValues.has(b.value);
    if (aIsPreviouslySelected && !bIsPreviouslySelected) return -1;
    if (!aIsPreviouslySelected && bIsPreviouslySelected) return 1;
  }
  return 0;
};
const getGroupedItems = items => {
  const groups = new Map();
  items.forEach(item => {
    const group = item.group || "Ungrouped";
    const groupItems = groups.get(group) || [];
    groupItems.push(item);
    groups.set(group, groupItems);
  });
  return Array.from(groups, _ref => {
    let [group, items] = _ref;
    return {
      group,
      items
    };
  });
};
const MultiSelectDropdown = _ref2 => {
  let {
    items,
    selectedItems,
    disabledItems,
    header,
    updateItems,
    onSelectItem,
    onDeselectItem,
    isOpen,
    footer,
    sortFn = sortAlphabetically,
    groupFn = getGroupedItems,
    hasSelectedItemsFirst = true,
    ...props
  } = _ref2;
  const selectedItemValues = (0, _react.useMemo)(() => new Set(selectedItems.map(item => item.value)), [selectedItems]);
  const disabledItemValues = (0, _react.useMemo)(() => new Set(disabledItems.map(item => item.value)), [disabledItems]);
  const [previouslySelectedItemValues, setPreviouslySelectedItemValues] = (0, _react.useState)(new Set(selectedItemValues));
  (0, _react.useEffect)(() => {
    if (isOpen) {
      setPreviouslySelectedItemValues(new Set(selectedItemValues));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]);
  const hasGroup = (0, _react.useMemo)(() => items.some(item => item.group), [items]);
  const groupedItems = (0, _react.useMemo)(() => hasGroup ? groupFn(items) : [{
    group: "Ungrouped",
    items
  }],
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [items, groupFn]);
  const handleOnChange = event => {
    const {
      checked,
      value
    } = event.target;
    const foundItem = items.find(item => "".concat(item.value) === value);
    if (foundItem) {
      var _selectedItems$filter;
      const newSelectedItems = checked ? [...selectedItems, foundItem] : (_selectedItems$filter = selectedItems.filter(item => "".concat(item.value) !== value)) !== null && _selectedItems$filter !== void 0 ? _selectedItems$filter : [];
      updateItems(newSelectedItems);
      if (checked) {
        onSelectItem === null || onSelectItem === void 0 || onSelectItem(foundItem);
      } else {
        onDeselectItem === null || onDeselectItem === void 0 || onDeselectItem(foundItem);
      }
    }
  };
  return /*#__PURE__*/_react.default.createElement(_FadeInDown.FadeInDown, {
    isVisible: isOpen
  }, /*#__PURE__*/_react.default.createElement("div", _extends({
    className: "multi-select__dropdown",
    role: "listbox"
  }, props), header ? header : null, groupedItems.map(_ref3 => {
    let {
      group,
      items
    } = _ref3;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "multi-select__group",
      key: group
    }, hasGroup ? /*#__PURE__*/_react.default.createElement("h5", {
      className: "multi-select__dropdown-header"
    }, group) : null, /*#__PURE__*/_react.default.createElement("ul", {
      className: "multi-select__dropdown-list",
      "aria-label": group
    }, items.toSorted(sortFn).toSorted(hasSelectedItemsFirst ? createSortSelectedItems(previouslySelectedItemValues) : () => 0).map(item => /*#__PURE__*/_react.default.createElement("li", {
      key: item.value,
      className: "multi-select__dropdown-item"
    }, /*#__PURE__*/_react.default.createElement(_index.CheckboxInput, {
      disabled: disabledItemValues.has(item.value),
      label: item.label,
      checked: selectedItemValues.has(item.value),
      value: item.value,
      onChange: handleOnChange,
      key: item.value
    })))));
  }), footer ? /*#__PURE__*/_react.default.createElement("div", {
    className: "multi-select__footer"
  }, footer) : null));
};

/**
 * Component allowing to select multiple items from a list of options.
 *
 * `MultiSelectDropdown` displays the dropdown with options which are grouped and sorted alphabetically.
 * `SearchBox` or `Button` is used to trigger the dropdown depending on the variant.
 */
exports.MultiSelectDropdown = MultiSelectDropdown;
MultiSelectDropdown.propTypes = {
  isOpen: _propTypes.default.bool.isRequired,
  items: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })).isRequired,
  selectedItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })).isRequired,
  disabledItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })).isRequired,
  header: _propTypes.default.node,
  updateItems: _propTypes.default.func.isRequired,
  onDeselectItem: _propTypes.default.func,
  onSelectItem: _propTypes.default.func,
  footer: _propTypes.default.node,
  groupFn: _propTypes.default.func,
  sortFn: _propTypes.default.any,
  hasSelectedItemsFirst: _propTypes.default.bool
};
const MultiSelect = _ref4 => {
  let {
    disabled,
    selectedItems: externalSelectedItems = [],
    label,
    listSelected = true,
    onItemsUpdate,
    onSelectItem,
    onDeselectItem,
    placeholder,
    required = false,
    items = [],
    disabledItems = [],
    dropdownHeader,
    dropdownFooter,
    showDropdownFooter = true,
    variant = "search",
    scrollOverflow = false,
    isSortedAlphabetically = true,
    hasSelectedItemsFirst = true,
    id,
    help,
    helpClassName
  } = _ref4;
  const buttonRef = (0, _react.useRef)(null);
  const [isDropdownOpen, setIsDropdownOpen] = (0, _react.useState)(false);
  const [filter, setFilter] = (0, _react.useState)("");
  const [internalSelectedItems, setInternalSelectedItems] = (0, _react.useState)([]);
  const selectedItems = externalSelectedItems || internalSelectedItems;
  const helpId = (0, _react.useId)();
  const updateItems = newItems => {
    const uniqueItems = Array.from(new Set(newItems));
    setInternalSelectedItems(uniqueItems);
    onItemsUpdate && onItemsUpdate(uniqueItems);
  };
  const dropdownId = (0, _react.useId)();
  const inputId = (0, _react.useId)();
  const selectedItemsLabel = selectedItems.filter(selectedItem => items.some(item => item.value === selectedItem.value)).map(el => el.label).join(", ");
  let footer = null;
  if (showDropdownFooter) {
    footer = dropdownFooter ? dropdownFooter : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_index.Button, {
      appearance: "link",
      onClick: () => {
        const enabledItems = items.filter(item => !disabledItems.some(disabledItem => disabledItem.value === item.value));
        updateItems([...selectedItems, ...enabledItems]);
      },
      type: "button"
    }, "Select all"), /*#__PURE__*/_react.default.createElement(_index.Button, {
      appearance: "link",
      onClick: () => {
        const disabledSelectedItems = selectedItems.filter(item => disabledItems.some(disabledItem => disabledItem.value === item.value));
        updateItems(disabledSelectedItems);
      },
      type: "button"
    }, "Clear"));
  }
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_index.ContextualMenu, {
    className: "multi-select",
    onToggleMenu: isOpen => {
      if (!isOpen) {
        setFilter("");
      }
      // Handle syncing the state when toggling the menu from within the
      // contextual menu component e.g. when clicking outside.
      if (isOpen !== isDropdownOpen) {
        setIsDropdownOpen(isOpen);
      }
    },
    position: "left",
    constrainPanelWidth: true,
    toggle: variant === "search" ? /*#__PURE__*/_react.default.createElement(_index.SearchBox, {
      externallyControlled: true,
      "aria-controls": dropdownId,
      "aria-expanded": isDropdownOpen,
      id: id !== null && id !== void 0 ? id : inputId,
      role: "combobox",
      "aria-label": label || placeholder || "Search",
      disabled: disabled,
      autoComplete: "off",
      onChange: value => {
        setFilter(value);
        // reopen if dropdown has been closed via ESC
        setIsDropdownOpen(true);
      },
      onFocus: () => setIsDropdownOpen(true),
      placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : "Search",
      required: required,
      type: "text",
      value: filter,
      className: "multi-select__input"
    }) : /*#__PURE__*/_react.default.createElement("button", {
      role: "combobox",
      type: "button",
      "aria-label": label || placeholder || "Select items",
      "aria-controls": dropdownId,
      "aria-expanded": isDropdownOpen,
      className: "multi-select__select-button",
      onClick: () => {
        setIsDropdownOpen(!isDropdownOpen);
      },
      onMouseDown: event => {
        // If the dropdown is open when this button is clicked the
        // click-outside event will fire which will close the dropdown, but
        // then the button click event will fire which will immediately
        // reopen the dropdown.
        // To prevent this we can stop the propagation to the click event
        // while `isDropdownOpen` is still set to `true` (by the time we
        // get to the `onClick` event `isDropdownOpen` will already be `false`,
        // hence having to do this on mouse down).
        if (isDropdownOpen) {
          event.stopPropagation();
        }
      },
      ref: buttonRef,
      id: id,
      disabled: disabled
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: "multi-select__condensed-text"
    }, listSelected && selectedItems.length > 0 ? selectedItemsLabel : placeholder !== null && placeholder !== void 0 ? placeholder : "Select items")),
    visible: isDropdownOpen,
    scrollOverflow: scrollOverflow,
    "aria-describedby": help ? helpId : undefined
  }, /*#__PURE__*/_react.default.createElement(MultiSelectDropdown, {
    id: dropdownId,
    isOpen: isDropdownOpen,
    items: filter.length > 0 ? items.filter(item => item.label.toLowerCase().includes(filter.toLowerCase())) : items,
    selectedItems: selectedItems,
    disabledItems: disabledItems,
    header: dropdownHeader,
    updateItems: updateItems,
    onSelectItem: onSelectItem,
    onDeselectItem: onDeselectItem,
    footer: footer,
    sortFn: isSortedAlphabetically ? sortAlphabetically : () => 0,
    hasSelectedItemsFirst: hasSelectedItemsFirst
  })), help && /*#__PURE__*/_react.default.createElement("p", {
    className: (0, _classnames.default)("p-form-help-text", helpClassName),
    id: helpId
  }, help));
};
exports.MultiSelect = MultiSelect;
MultiSelect.propTypes = {
  disabled: _propTypes.default.bool,
  error: _propTypes.default.string,
  selectedItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })),
  help: _propTypes.default.node,
  helpClassName: _propTypes.default.string,
  label: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.oneOf([null])]),
  listSelected: _propTypes.default.bool,
  onDeselectItem: _propTypes.default.func,
  onItemsUpdate: _propTypes.default.func,
  onSelectItem: _propTypes.default.func,
  placeholder: _propTypes.default.string,
  required: _propTypes.default.bool,
  items: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })).isRequired,
  disabledItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.string.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.number]).isRequired,
    group: _propTypes.default.string
  })),
  renderItem: _propTypes.default.func,
  dropdownHeader: _propTypes.default.node,
  dropdownFooter: _propTypes.default.node,
  showDropdownFooter: _propTypes.default.bool,
  variant: _propTypes.default.oneOf(["condensed", "search"]),
  scrollOverflow: _propTypes.default.bool,
  isSortedAlphabetically: _propTypes.default.bool,
  hasSelectedItemsFirst: _propTypes.default.bool,
  id: _propTypes.default.string
};