"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _Pagination = _interopRequireDefault(require("../Pagination"));
var _Table = _interopRequireDefault(require("../Table"));
var _TableRow = _interopRequireDefault(require("../TableRow"));
var _TableHeader = _interopRequireDefault(require("../TableHeader"));
var _TableCell = _interopRequireDefault(require("../TableCell"));
var _hooks = require("../../hooks");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
const updateSort = (setSortKey, setSortDirection, sortKey, sortDirection) => {
  let newDirection = null;
  if (sortDirection === "none") {
    newDirection = "ascending";
  } else if (sortDirection === "ascending") {
    newDirection = "descending";
  } else {
    sortKey = null;
  }
  setSortKey(sortKey);
  setSortDirection(newDirection);
};
const generateHeaders = (currentSortKey, currentSortDirection, expanding, headers, sortable, setSortKey, setSortDirection) => {
  const headerItems = headers.map((_ref, index) => {
    let {
      content,
      sortKey,
      ...props
    } = _ref;
    let sortDirection;
    if (sortable && sortKey) {
      if (currentSortKey === sortKey) {
        sortDirection = currentSortDirection;
      } else {
        sortDirection = "none";
      }
    }
    return /*#__PURE__*/_react.default.createElement(_TableHeader.default, _extends({
      key: index,
      sort: sortDirection,
      onClick: sortable && sortKey ? updateSort.bind(void 0, setSortKey, setSortDirection, sortKey, sortDirection) : undefined
    }, props), content);
  });
  // When there is expanding content then provide an extra hidden header to
  // account for the extra cell in the body rows.
  return /*#__PURE__*/_react.default.createElement("thead", null, /*#__PURE__*/_react.default.createElement(_TableRow.default, null, headerItems, expanding && /*#__PURE__*/_react.default.createElement(_TableHeader.default, {
    "aria-hidden": "true"
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: "u-off-screen"
  }, "Empty"))));
};
const generateRows = _ref2 => {
  let {
    rows,
    headers,
    responsive,
    expanding
  } = _ref2;
  return rows.map((_ref3, index) => {
    let {
      columns,
      expanded,
      expandedContent,
      key,
      sortData: _,
      ...rowProps
    } = _ref3;
    const cellItems = columns === null || columns === void 0 ? void 0 : columns.map((_ref4, index) => {
      let {
        content,
        ...cellProps
      } = _ref4;
      const headerContent = headers && headers[index]["content"];
      const headerReplacement = headers && headers[index]["heading"];
      if (responsive) {
        cellProps["data-heading"] = typeof headerContent === "string" ? headerContent : headerReplacement;
      }
      return /*#__PURE__*/_react.default.createElement(_TableCell.default, _extends({
        key: index
      }, cellProps), content);
    });
    // if key was not provided as a prop, use row's index instead
    if (key === null || typeof key === "undefined") {
      key = index;
    }

    // The expanding cell is alway created to match the correct number of
    // table cells in rows that do have expanding content.
    return /*#__PURE__*/_react.default.createElement(_TableRow.default, _extends({
      key: key
    }, rowProps), cellItems, expanding && /*#__PURE__*/_react.default.createElement(_TableCell.default, {
      expanding: true,
      hidden: !expanded
    }, expandedContent));
  });
};
const sortRows = _ref5 => {
  let {
    currentSortDirection,
    currentSortKey,
    rows,
    sortable,
    sortFunction
  } = _ref5;
  if (!rows) {
    return [];
  }
  // Clone the rows so we can restore the original order.
  const sortedRows = [...rows];
  if (sortable && currentSortKey) {
    if (!sortFunction) {
      sortFunction = (a, b) => {
        if (!a.sortData || !b.sortData) {
          return 0;
        }
        if (a.sortData[currentSortKey] > b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? 1 : -1;
        } else if (a.sortData[currentSortKey] < b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? -1 : 1;
        }
        return 0;
      };
    }
    sortedRows.sort((a, b) => sortFunction(a, b, currentSortDirection, currentSortKey));
  }
  return sortedRows;
};

/**
 * This is a [React](https://reactjs.org/) component to support many table use cases.
 */
const MainTable = _ref6 => {
  let {
    defaultSort,
    defaultSortDirection,
    emptyStateMsg = "",
    expanding,
    headers,
    onUpdateSort,
    paginate,
    rows,
    responsive,
    sortable,
    sortFunction,
    hiddenCaption,
    ...props
  } = _ref6;
  const [currentSortKey, setSortKey] = (0, _react.useState)(defaultSort);
  const [currentSortDirection, setSortDirection] = (0, _react.useState)(defaultSortDirection);

  // Update the current sort state if the prop changes.
  (0, _react.useEffect)(() => {
    setSortKey(defaultSort);
  }, [defaultSort]);

  // Update the current sort direction state if the prop changes.
  (0, _react.useEffect)(() => {
    setSortDirection(defaultSortDirection);
  }, [defaultSortDirection]);
  const updateSort = newSort => {
    setSortKey(newSort);
    onUpdateSort && onUpdateSort(newSort);
  };
  const sortedRows = (0, _react.useMemo)(() => sortRows({
    currentSortDirection,
    currentSortKey,
    rows,
    sortable,
    sortFunction
  }), [currentSortDirection, currentSortKey, rows, sortable, sortFunction]);
  const {
    pageData: finalRows,
    currentPage,
    paginate: setCurrentPage
  } = (0, _hooks.usePagination)(sortedRows, {
    itemsPerPage: paginate,
    autoResetPage: true
  });
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_Table.default, _extends({
    expanding: expanding,
    responsive: responsive
  }, props), hiddenCaption && /*#__PURE__*/_react.default.createElement("caption", {
    "data-testid": "hidden-caption",
    style: {
      height: "1px",
      left: "-1000px",
      overflow: "hidden",
      position: "absolute",
      top: "auto",
      width: "1px"
    }
  }, hiddenCaption), !!headers && generateHeaders(currentSortKey, currentSortDirection, expanding, headers, sortable, updateSort, setSortDirection),
  // If the table has no rows, return empty state message
  Object.entries(finalRows).length === 0 && emptyStateMsg ? /*#__PURE__*/_react.default.createElement("caption", null, emptyStateMsg) : /*#__PURE__*/_react.default.createElement("tbody", null, generateRows({
    rows: finalRows,
    headers,
    responsive,
    expanding
  }))), paginate && rows && rows.length > 0 && /*#__PURE__*/_react.default.createElement(_Pagination.default, {
    currentPage: currentPage,
    itemsPerPage: paginate,
    paginate: setCurrentPage,
    style: {
      marginTop: "1rem"
    },
    totalItems: rows.length
  }));
};
var _default = exports.default = MainTable;