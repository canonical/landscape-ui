"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useWindowFitment = void 0;
var _react = require("react");
var _useListener = require("./useListener");
/**
 * A hook to determine if an element fits on the window.
 * @param targetNode The element to try and fit on the window.
 * @param referenceNode The element to use to position the target.
 * @param callback The function to call when updating fitment info.
 * @param spacer An additional space to leave between the target and reference.
 * @param shouldCheck Whether the fitment info should be being checked.
 * @param fromMouse Whether the target should be being positioned in relation
 *                  to the mouse. In this case refernceNode will be used to
 *                  listen for mouseover events.
 */
const useWindowFitment = function (targetNode, referenceNode, callback) {
  let spacer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  let shouldCheck = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  let fromMouse = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  const htmlRef = (0, _react.useRef)(document.querySelector("html"));
  const update = (0, _react.useCallback)(evt => {
    let referenceCoordinates;
    if (fromMouse) {
      if (evt) {
        referenceCoordinates = {
          // The mouse is a single point so use 0 for the height and width.
          height: 0,
          left: ("x" in evt && typeof evt.x === "number" ? evt.x : null) || 0,
          top: ("y" in evt && typeof evt.y === "number" ? evt.y : null) || 0,
          width: 0
        };
      }
    } else if (referenceNode) {
      referenceCoordinates = referenceNode.getBoundingClientRect();
    }
    if (shouldCheck && targetNode && referenceCoordinates) {
      const {
        height: targetHeight,
        width: targetWidth
      } = targetNode.getBoundingClientRect();
      const {
        height: referenceHeight,
        left: referenceLeft,
        top: referenceTop,
        width: referenceWidth
      } = referenceCoordinates;
      const referenceBottom = referenceTop + referenceHeight;
      const referenceRight = referenceLeft + referenceWidth;
      const referenceCenterX = referenceLeft + referenceWidth / 2;
      const referenceCenterY = referenceTop + referenceHeight / 2;
      const windowLeft = htmlRef.current.scrollLeft;
      const windowRight = window.innerWidth - htmlRef.current.scrollLeft;
      const windowTop = 0;
      const windowBottom = window.innerHeight;
      const heightIncludingSpace = targetHeight + spacer;
      const widthIncludingSpace = targetWidth + spacer;
      const widthFromCenter = targetWidth / 2;
      const heightFromCenter = targetHeight / 2;
      callback({
        fromTop: {
          fitsAbove: referenceTop - heightIncludingSpace > windowTop,
          fitsBelow: referenceTop + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceTop),
          spaceBelow: windowBottom - referenceTop
        },
        fromBottom: {
          fitsAbove: referenceBottom - heightIncludingSpace > windowTop,
          fitsBelow: referenceBottom + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceBottom),
          spaceBelow: windowBottom - referenceBottom
        },
        fromLeft: {
          fitsLeft: referenceLeft - widthIncludingSpace > windowLeft,
          fitsRight: referenceLeft + widthIncludingSpace < windowRight,
          spaceLeft: Math.abs(windowLeft - referenceLeft),
          spaceRight: windowRight - referenceLeft
        },
        fromRight: {
          fitsLeft: referenceRight - widthIncludingSpace > windowLeft,
          fitsRight: referenceRight + widthIncludingSpace < windowRight,
          spaceLeft: Math.abs(windowLeft - referenceRight),
          spaceRight: windowRight - referenceRight
        },
        fromCenter: {
          fitsLeft: referenceCenterX - widthIncludingSpace > windowLeft,
          fitsRight: referenceCenterX + widthIncludingSpace < windowRight,
          fitsAbove: referenceCenterY - heightIncludingSpace > windowTop,
          fitsBelow: referenceCenterY + heightIncludingSpace < windowBottom,
          spaceAbove: Math.abs(windowTop - referenceCenterY),
          spaceBelow: windowBottom - referenceCenterY,
          spaceLeft: Math.abs(windowLeft - referenceCenterX),
          spaceRight: windowRight - referenceCenterX,
          fitsCentered: {
            fitsLeft: referenceCenterX - widthFromCenter > windowLeft,
            fitsRight: referenceCenterX + widthFromCenter < windowRight,
            fitsAbove: referenceCenterY - heightFromCenter > windowTop,
            fitsBelow: referenceCenterY + heightFromCenter < windowBottom
          }
        }
      });
    }
  }, [shouldCheck, targetNode, callback, spacer, fromMouse, referenceNode]);
  (0, _useListener.useListener)(window, update, "resize", true, shouldCheck && !fromMouse);
  (0, _useListener.useListener)(window, update, "scroll", true, shouldCheck && !fromMouse);
  (0, _useListener.useListener)(referenceNode, update, "mousemove", true, fromMouse && shouldCheck);
  (0, _react.useEffect)(() => {
    if (!fromMouse) {
      update();
    }
  }, [fromMouse, update]);
};
exports.useWindowFitment = useWindowFitment;