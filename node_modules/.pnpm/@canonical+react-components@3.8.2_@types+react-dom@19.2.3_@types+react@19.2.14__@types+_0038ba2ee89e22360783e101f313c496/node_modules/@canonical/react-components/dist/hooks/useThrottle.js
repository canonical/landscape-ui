"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useThrottle = exports.THROTTLE_DELAY = void 0;
var _react = require("react");
const THROTTLE_DELAY = exports.THROTTLE_DELAY = 1000 / 60;
// eslint-disable-line @typescript-eslint/no-explicit-any

/**
 * A hook to handle throttling calls to a function.
 * @param callback The function to throttle.
 * @param delay The throttle delay in ms.
 * @return The callback function wrapped in the throttle.
 */
const useThrottle = function (callback) {
  let delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : THROTTLE_DELAY;
  const timeout = (0, _react.useRef)(null);
  const lastCall = (0, _react.useRef)(null);
  const lastArgs = (0, _react.useRef)(null);
  const throttle = (0, _react.useCallback)(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs.current = args;
    const callCallback = () => {
      callback(...lastArgs.current);
      lastCall.current = Date.now();
      timeout.current = null;
    };
    const createTimeout = () => {
      timeout.current = window.setTimeout(() => {
        callCallback();
        timeout.current = null;
      }, delay);
    };
    if (!lastCall.current) {
      // Initially call the callback and start a timeout for the next call.
      callCallback();
      createTimeout();
    } else if (!timeout.current && Date.now() - lastCall.current > delay) {
      // If a timeout isn't active then create a new one if the delay time
      // has elapsed.
      createTimeout();
    }
  }, [callback, delay]);
  (0, _react.useEffect)(() => () => {
    // Clear the timeout when unmounting.
    if (timeout.current) {
      clearTimeout(timeout.current);
    }
  }, []);
  return throttle;
};
exports.useThrottle = useThrottle;