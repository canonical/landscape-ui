"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useListener = void 0;
var _react = require("react");
var _useThrottle = require("./useThrottle");
var _usePrevious = require("./usePrevious");
/**
 * A hook that handles attaching/removing listeners and smartly reattaching if
 * any of the attributes change.
 * @param targetNode The node to attach the listener to.
 * @param callback The function to call from the listener.
 * @param eventType The event name.
 * @param shouldThrottle Whether the callback calls should be throttled.
 * @param shouldListen When the listener should be active.
 * @param options Native event listener options.
 */
const useListener = function (targetNode, callback, eventType) {
  let shouldThrottle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  let shouldListen = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  let options = arguments.length > 5 ? arguments[5] : undefined;
  const isListening = (0, _react.useRef)(false);
  const throttle = (0, _useThrottle.useThrottle)(callback);
  const eventListener = (0, _react.useRef)(shouldThrottle ? throttle : callback);
  const previousEventType = (0, _usePrevious.usePrevious)(eventType);
  const previousShouldThrottle = (0, _usePrevious.usePrevious)(shouldThrottle);
  const previousTargetNode = (0, _usePrevious.usePrevious)(targetNode);
  const previousCallback = (0, _usePrevious.usePrevious)(callback);
  const previousOptions = (0, _usePrevious.usePrevious)(options);
  (0, _react.useEffect)(() => {
    // If any of the props related to the attached listener changed then the
    // listener needs to be re-attached.
    const listenerAttributesChanged = callback !== previousCallback || eventType !== previousEventType || shouldThrottle !== previousShouldThrottle || targetNode !== previousTargetNode || options !== previousOptions;
    if (isListening.current && (!shouldListen || listenerAttributesChanged)) {
      previousTargetNode.removeEventListener(previousEventType, eventListener.current, previousOptions);
      isListening.current = false;
    }
    if (shouldThrottle !== previousShouldThrottle || callback !== previousCallback) {
      // Set the listener to the callback, or used the throttled callback.
      eventListener.current = shouldThrottle ? throttle : callback;
    }
    if (targetNode && shouldListen && !isListening.current) {
      targetNode.addEventListener(eventType, eventListener.current, options);
      isListening.current = true;
    }
    return () => {
      // Unattach the listener if the component gets unmounted while
      // listening.
      if (targetNode && eventListener.current && isListening.current) {
        targetNode.removeEventListener(eventType, eventListener.current, options);
        isListening.current = false;
      }
    };
  }, [callback, eventType, options, previousCallback, previousEventType, previousOptions, previousShouldThrottle, previousTargetNode, shouldListen, shouldThrottle, targetNode, throttle]);
};
exports.useListener = useListener;