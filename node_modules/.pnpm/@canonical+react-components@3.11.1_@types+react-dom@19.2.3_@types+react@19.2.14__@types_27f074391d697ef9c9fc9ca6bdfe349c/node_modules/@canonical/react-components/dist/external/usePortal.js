"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.usePortal = exports.errorMessage1 = void 0;
var _react = require("react");
var _reactDom = require("react-dom");
var _useSSR = require("./useSSR");
/**
 * This is a reference implementation of the usePortal hook from react-useportal: https://github.com/iamthesiz/react-useportal/blob/master/usePortal.ts
 * The license for the content in this file is goverened by the original project's license: https://github.com/iamthesiz/react-useportal/blob/master/license.md
 */

const errorMessage1 = exports.errorMessage1 = "You must either add a `ref` to the element you are interacting with or pass an `event` to openPortal(e) or togglePortal(e) when the `programmaticallyOpen` option is not set to `true`.";
const usePortal = function () {
  let {
    closeOnOutsideClick = true,
    closeOnEsc = true,
    bindTo,
    // attach the portal to this node in the DOM
    isOpen: defaultIsOpen = false,
    onOpen,
    onClose,
    onPortalClick,
    programmaticallyOpen = false
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const {
    isServer,
    isBrowser
  } = (0, _useSSR.useSSR)();
  const [isOpen, makeOpen] = (0, _react.useState)(defaultIsOpen);
  // we use this ref because `isOpen` is stale for handleOutsideMouseClick
  const open = (0, _react.useRef)(isOpen);
  const setOpen = (0, _react.useCallback)(v => {
    // workaround to not have stale `isOpen` in the handleOutsideMouseClick
    open.current = v;
    makeOpen(v);
  }, []);
  const targetEl = (0, _react.useRef)(null); // this is the element you are clicking/hovering/whatever, to trigger opening the portal
  const portal = (0, _react.useRef)(isBrowser ? document.createElement("div") : null);
  (0, _react.useEffect)(() => {
    if (isBrowser && !portal.current) portal.current = document.createElement("div");
  }, [isBrowser, portal]);
  const elToMountTo = (0, _react.useMemo)(() => {
    if (isServer) return null;
    return bindTo && bindTo.current || document.body;
  }, [isServer, bindTo]);
  const createCustomEvent = e => {
    if (!e) return {
      portal,
      targetEl,
      event: e
    };
    const event = e || {};
    if (event.persist) event.persist();
    event.portal = portal;
    event.targetEl = targetEl;
    event.event = e;
    const {
      currentTarget
    } = e;
    if (!targetEl.current && currentTarget && currentTarget !== document) targetEl.current = event.currentTarget;
    return event;
  };
  const openPortal = (0, _react.useCallback)(e => {
    if (isServer) return;
    const customEvent = createCustomEvent(e);
    // for some reason, when we don't have the event argument, there
    // is a weird race condition. Would like to see if we can remove
    // setTimeout, but for now this works
    if (targetEl.current == null && !programmaticallyOpen) {
      setTimeout(() => setOpen(true), 0);
      throw Error(errorMessage1);
    }
    if (onOpen) onOpen(customEvent);
    setOpen(true);
  }, [isServer, portal, setOpen, targetEl, onOpen, programmaticallyOpen]);
  const closePortal = (0, _react.useCallback)(e => {
    if (isServer) return;
    const customEvent = createCustomEvent(e);
    if (onClose && open.current) onClose(customEvent);
    if (open.current) setOpen(false);
  }, [isServer, onClose, setOpen]);
  const togglePortal = (0, _react.useCallback)(e => open.current ? closePortal(e) : openPortal(e), [closePortal, openPortal]);
  const handleKeydown = (0, _react.useCallback)(e => e.key === "Escape" && closeOnEsc ? closePortal(e) : undefined, [closeOnEsc, closePortal]);
  const handleOutsideMouseClick = (0, _react.useCallback)(e => {
    const containsTarget = target => target.current.contains(e.target);
    // There might not be a targetEl if the portal was opened programmatically.
    if (containsTarget(portal) || e.button !== 0 || !open.current || targetEl.current && containsTarget(targetEl)) return;
    if (closeOnOutsideClick) closePortal(e);
  }, [isServer, closePortal, closeOnOutsideClick, portal]);
  const handleMouseDown = (0, _react.useCallback)(e => {
    if (isServer || !(portal.current instanceof HTMLElement)) return;
    const customEvent = createCustomEvent(e);
    if (portal.current.contains(customEvent.target) && onPortalClick) onPortalClick(customEvent);
    handleOutsideMouseClick(e);
  }, [handleOutsideMouseClick, isServer]);
  (0, _react.useEffect)(() => {
    if (isServer) return null;
    if (!(elToMountTo instanceof HTMLElement) || !(portal.current instanceof HTMLElement)) return null;
    const node = portal.current;
    elToMountTo.appendChild(portal.current);
    document.addEventListener("keydown", handleKeydown);
    document.addEventListener("mousedown", handleMouseDown);
    return () => {
      document.removeEventListener("keydown", handleKeydown);
      document.removeEventListener("mousedown", handleMouseDown);
      elToMountTo.removeChild(node);
    };
  }, [isServer, handleOutsideMouseClick, handleKeydown, elToMountTo, portal]);
  const Portal = (0, _react.useCallback)(_ref => {
    let {
      children
    } = _ref;
    if (portal.current != null) return /*#__PURE__*/(0, _reactDom.createPortal)(children, portal.current);
    return null;
  }, [portal]);
  return Object.assign([openPortal, closePortal, open.current, Portal, togglePortal, targetEl, portal], {
    isOpen: open.current,
    openPortal,
    ref: targetEl,
    closePortal,
    togglePortal,
    Portal,
    portalRef: portal,
    bind: {
      // used if you want to spread all html attributes onto the target element
      ref: targetEl
    }
  });
};
exports.usePortal = usePortal;