"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOptionText = exports.dropdownIsAbove = exports.default = exports.adjustDropdownHeightBelow = exports.adjustDropdownHeightAbove = exports.adjustDropdownHeight = void 0;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var _hooks = require("../../../hooks");
var _SearchBox = _interopRequireDefault(require("../../SearchBox"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DROPDOWN_MAX_HEIGHT = 16 * 30; // 30rem with base 16px
const DROPDOWN_MARGIN = 20;
const adjustDropdownHeightBelow = dropdown => {
  var _window$visualViewpor;
  const dropdownRect = dropdown.getBoundingClientRect();
  const dropdownHeight = dropdown.offsetHeight;
  const viewportHeight = ((_window$visualViewpor = window.visualViewport) === null || _window$visualViewpor === void 0 ? void 0 : _window$visualViewpor.height) || window.innerHeight;

  // If the dropdown is cut off at the bottom of the viewport
  // adjust the height to fit within the viewport minus fixed margin.
  // This usually becomes an issue when the dropdown is at the bottom of the viewport or screen getting smaller.
  if (dropdownRect.bottom >= viewportHeight) {
    const adjustedHeight = dropdownHeight - dropdownRect.bottom + viewportHeight - DROPDOWN_MARGIN;
    dropdown.style.height = "".concat(adjustedHeight, "px");
    dropdown.style.maxHeight = "".concat(adjustedHeight, "px");
    return;
  }

  // If the dropdown does not have overflow, the dropdown should fit its content.
  const hasOverflow = dropdown.scrollHeight > dropdown.clientHeight;
  if (!hasOverflow) {
    dropdown.style.height = "auto";
    dropdown.style.maxHeight = "";
    return;
  }

  // If the dropdown is not cut off at the bottom of the viewport
  // adjust the height of the dropdown so that its bottom edge is 20px from the bottom of the viewport
  // until the dropdown max height is reached.
  const adjustedHeight = Math.min(viewportHeight - dropdownRect.top - DROPDOWN_MARGIN, DROPDOWN_MAX_HEIGHT);
  dropdown.style.height = "".concat(adjustedHeight, "px");
  dropdown.style.maxHeight = "".concat(adjustedHeight, "px");
};
exports.adjustDropdownHeightBelow = adjustDropdownHeightBelow;
const adjustDropdownHeightAbove = (dropdown, search) => {
  // The search height is subtracted (if necessary) so that no options will be hidden behind the search input.
  const searchRect = search === null || search === void 0 ? void 0 : search.getBoundingClientRect();
  const searchHeight = (searchRect === null || searchRect === void 0 ? void 0 : searchRect.height) || 0;
  const dropdownRect = dropdown.getBoundingClientRect();

  // If the dropdown does not have overflow, do not adjust.
  const hasOverflow = dropdown.scrollHeight > dropdown.clientHeight;
  if (!hasOverflow) {
    dropdown.style.height = "auto";
    dropdown.style.maxHeight = "";
    return;
  }

  // adjust the height of the dropdown so that its top edge is 20px from the top of the viewport.
  // until the dropdown max height is reached.
  // unlike the case where the dropdown is bellow the toggle, dropdown.bottom represents the available space above the toggle always.
  // this makes the calculation simpler since we only need to work with dropdown.bottom regardless if the element is cut off or not.
  const adjustedHeight = Math.min(dropdownRect.bottom - searchHeight - DROPDOWN_MARGIN, DROPDOWN_MAX_HEIGHT);
  dropdown.style.height = "".concat(adjustedHeight, "px");
  dropdown.style.maxHeight = "".concat(adjustedHeight, "px");
};
exports.adjustDropdownHeightAbove = adjustDropdownHeightAbove;
const dropdownIsAbove = dropdown => {
  const toggle = document.querySelector(".p-custom-select__toggle");
  const dropdownRect = dropdown.getBoundingClientRect();
  const toggleRect = toggle.getBoundingClientRect();
  return toggleRect.top >= dropdownRect.bottom;
};
exports.dropdownIsAbove = dropdownIsAbove;
const adjustDropdownHeight = (dropdown, search) => {
  if (!dropdown) {
    return;
  }
  if (dropdownIsAbove(dropdown)) {
    adjustDropdownHeightAbove(dropdown, search);
    return;
  }
  adjustDropdownHeightBelow(dropdown);
};
exports.adjustDropdownHeight = adjustDropdownHeight;
const getOptionText = option => {
  if (option.text) {
    return option.text;
  }
  if (typeof option.label === "string") {
    return option.label;
  }
  throw new Error("CustomSelect: options must have a string label or a text property");
};
exports.getOptionText = getOptionText;
const getIsSearchable = (searchable, numberOfOptions) => {
  if (searchable === "async") {
    return true;
  }
  if (searchable === "never") {
    return false;
  }
  if (numberOfOptions <= 1) {
    return false;
  }
  if (searchable === "always") {
    return true;
  }
  if (searchable === "auto" && numberOfOptions >= 5) {
    return true;
  }
  return false;
};
const CustomSelectDropdown = _ref => {
  let {
    searchable,
    searchPlaceholder,
    name,
    options,
    onSelect,
    onSearch,
    onClose,
    header,
    toggleId
  } = _ref;
  const [search, setSearch] = (0, _react.useState)("");
  // track highlighted option index for keyboard actions
  const [highlightedOptionIndex, setHighlightedOptionIndex] = (0, _react.useState)(0);
  // use ref to keep a reference to all option HTML elements so we do not need to make DOM calls later for scrolling
  const optionsRef = (0, _react.useRef)([]);
  const dropdownRef = (0, _react.useRef)(null);
  const searchRef = (0, _react.useRef)(null);
  const dropdownListRef = (0, _react.useRef)(null);
  const isSearchable = getIsSearchable(searchable, options.length);
  (0, _react.useEffect)(() => {
    if (dropdownRef.current) {
      var _toggle$getBoundingCl, _toggle$getBoundingCl2;
      const toggle = document.getElementById(toggleId);

      // align width with wrapper toggle width
      const toggleWidth = (_toggle$getBoundingCl = toggle === null || toggle === void 0 || (_toggle$getBoundingCl2 = toggle.getBoundingClientRect()) === null || _toggle$getBoundingCl2 === void 0 ? void 0 : _toggle$getBoundingCl2.width) !== null && _toggle$getBoundingCl !== void 0 ? _toggle$getBoundingCl : 0;
      dropdownRef.current.style.setProperty("min-width", "".concat(toggleWidth, "px"));
    }
    setTimeout(() => {
      var _dropdownRef$current;
      if (isSearchable) {
        var _searchRef$current;
        (_searchRef$current = searchRef.current) === null || _searchRef$current === void 0 || _searchRef$current.focus();
        return;
      }
      (_dropdownRef$current = dropdownRef.current) === null || _dropdownRef$current === void 0 || _dropdownRef$current.focus();
    }, 100);
  }, [isSearchable, toggleId]);
  const handleResize = () => {
    adjustDropdownHeight(dropdownListRef.current, searchRef.current);
  };
  (0, _react.useLayoutEffect)(handleResize, []);
  (0, _hooks.useListener)(window, handleResize, "resize");

  // track selected index from key board action and scroll into view if needed
  (0, _react.useEffect)(() => {
    var _optionsRef$current$h;
    (_optionsRef$current$h = optionsRef.current[highlightedOptionIndex]) === null || _optionsRef$current$h === void 0 || _optionsRef$current$h.scrollIntoView({
      block: "nearest",
      inline: "nearest"
    });
  }, [highlightedOptionIndex]);
  const filteredOptions = onSearch ? options : options === null || options === void 0 ? void 0 : options.filter(option => {
    if (!search || option.disabled) return true;
    const searchText = getOptionText(option) || option.value;
    return searchText.toLowerCase().includes(search);
  });
  const getNextOptionIndex = (goingUp, prevIndex) => {
    const increment = goingUp ? -1 : 1;
    let currIndex = prevIndex + increment;
    // skip disabled options for key board action
    while (filteredOptions[currIndex] && (_filteredOptions$curr = filteredOptions[currIndex]) !== null && _filteredOptions$curr !== void 0 && _filteredOptions$curr.disabled) {
      var _filteredOptions$curr;
      currIndex += increment;
    }

    // consider upper bound for navigating down the list
    if (increment > 0) {
      return currIndex < filteredOptions.length ? currIndex : prevIndex;
    }

    // consider lower bound for navigating up the list
    return currIndex >= 0 ? currIndex : prevIndex;
  };

  // handle keyboard actions for navigating the select dropdown
  const handleKeyDown = event => {
    const upDownKeys = ["ArrowUp", "ArrowDown"];

    // prevent default browser actions for up, down, enter and escape keys
    // also prevent any other event listeners from being called up the DOM tree
    if ([...upDownKeys, "Enter", "Escape", "Tab"].includes(event.key)) {
      event.preventDefault();
      event.nativeEvent.stopImmediatePropagation();
    }
    if (upDownKeys.includes(event.key)) {
      setHighlightedOptionIndex(prevIndex => {
        const goingUp = event.key === "ArrowUp";
        return getNextOptionIndex(goingUp, prevIndex);
      });
    }
    if (event.key === "Enter" && filteredOptions[highlightedOptionIndex]) {
      onSelect(filteredOptions[highlightedOptionIndex].value);
    }
    if (event.key === "Escape" || event.key === "Tab") {
      onClose();
    }
  };
  const handleSearch = value => {
    setSearch(value.toLowerCase());
    // reset selected index when search text changes
    setHighlightedOptionIndex(0);
    optionsRef.current = [];
    if (onSearch) {
      onSearch(value);
    }
  };
  const handleSelect = option => {
    if (option.disabled) {
      return;
    }
    onSelect(option.value);
  };
  const optionItems = filteredOptions.map((option, idx) => {
    return /*#__PURE__*/_react.default.createElement("li", {
      key: "".concat(option.value, "-").concat(idx),
      onClick: () => handleSelect(option),
      className: (0, _classnames.default)("p-list__item", "p-custom-select__option", "u-truncate", {
        disabled: option.disabled,
        highlight: idx === highlightedOptionIndex && !option.disabled
      })
      // adding option elements to a ref array makes it easier to scroll the element later
      // else we'd have to make a DOM call to find the element based on some identifier
      ,
      ref: el => {
        if (!el) return;
        optionsRef.current[idx] = el;
      },
      role: "option",
      onMouseMove: () => setHighlightedOptionIndex(idx)
    }, /*#__PURE__*/_react.default.createElement("span", {
      className: (0, _classnames.default)({
        "u-text--muted": option.disabled
      })
    }, option.label));
  });
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "p-custom-select__dropdown u-no-padding",
    role: "combobox",
    onKeyDownCapture: handleKeyDown
    // allow focus on the dropdown so that keyboard actions can be captured
    ,
    tabIndex: -1,
    ref: dropdownRef,
    onMouseDown: e => {
      // when custom select is used in a modal, which is a portal, a dropdown click
      // should not close the modal itself, so we stop the event right here.
      e.stopPropagation();
    }
  }, isSearchable && /*#__PURE__*/_react.default.createElement("div", {
    className: "p-custom-select__search u-no-padding--bottom"
  }, /*#__PURE__*/_react.default.createElement(_SearchBox.default, {
    ref: searchRef,
    id: "select-search-".concat(name),
    name: "select-search-".concat(name),
    type: "text",
    "aria-label": "Search for ".concat(name),
    placeholder: searchPlaceholder,
    className: "u-no-margin--bottom",
    onChange: handleSearch,
    value: search,
    autocomplete: "off"
  })), header, /*#__PURE__*/_react.default.createElement("ul", {
    className: "p-list u-no-margin--bottom",
    role: "listbox",
    ref: dropdownListRef
  }, optionItems));
};
CustomSelectDropdown.propTypes = {
  searchable: _propTypes.default.oneOf(["auto", "always", "async", "never"]),
  searchPlaceholder: _propTypes.default.string,
  name: _propTypes.default.string.isRequired,
  options: _propTypes.default.array.isRequired,
  onSelect: _propTypes.default.func.isRequired,
  onSearch: _propTypes.default.func,
  onClose: _propTypes.default.func.isRequired,
  header: _propTypes.default.node,
  toggleId: _propTypes.default.string.isRequired
};
var _default = exports.default = CustomSelectDropdown;