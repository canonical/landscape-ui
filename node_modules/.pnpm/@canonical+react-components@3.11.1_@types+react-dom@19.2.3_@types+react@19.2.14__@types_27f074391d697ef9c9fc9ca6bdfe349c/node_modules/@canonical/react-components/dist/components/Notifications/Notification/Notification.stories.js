"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Timestamp = exports.Timeout = exports.Positive = exports.Negative = exports.Inline = exports.Information = exports.Dismissible = exports.Caution = exports.Borderless = exports.Actions = void 0;
var _react = _interopRequireWildcard(require("react"));
var _Notification = _interopRequireWildcard(require("./Notification"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const meta = {
  component: _Notification.default,
  tags: ["autodocs"],
  argTypes: {
    borderless: {
      control: {
        type: "boolean"
      }
    },
    children: {
      control: {
        type: "text"
      }
    },
    inline: {
      control: {
        type: "boolean"
      }
    },
    severity: {
      control: {
        type: "radio"
      },
      options: Object.values(_Notification.NotificationSeverity)
    },
    timestamp: {
      control: {
        type: "text"
      }
    },
    title: {
      control: {
        type: "text"
      }
    }
  },
  args: {
    borderless: false,
    inline: false,
    severity: _Notification.NotificationSeverity.INFORMATION
  }
};
var _default = exports.default = meta;
/**
 * The information severity should be used to convey an information message.
 */
const Information = exports.Information = {
  name: "Information",
  args: {
    children: "Anyone with access can view your invited users.",
    severity: "information",
    title: "Permissions changed"
  }
};

/**
 * The caution severity should be used to convey information that is not critical but the user should be aware of.
 */
const Caution = exports.Caution = {
  name: "Caution",
  args: {
    children: "Custom storage configuration is only supported on Ubuntu, CentOS and RHEL.",
    severity: "caution",
    title: "Blocked"
  }
};

/**
 * The negative severity should be used to convey information that is critical and the user should take action.
 */
const Negative = exports.Negative = {
  name: "Negative",
  args: {
    children: "Node must be connected to a network.",
    severity: "negative",
    title: "Error"
  }
};

/**
 * The positive severity should be used to convey success or completion.
 */
const Positive = exports.Positive = {
  name: "Positive",
  args: {
    children: "Code successfully reformatted.",
    severity: "positive",
    title: "Success"
  }
};

/**
 * When vertical space is limited, you can use the inline variant.
 */
const Inline = exports.Inline = {
  name: "Inline",
  args: {
    children: "Not enough space.",
    inline: true,
    severity: "negative",
    title: "Error:"
  }
};

/**
 * In cases where a notification sits inside another component, such as a table cell or a card, it may be useful to remove the outer border and highlight bar.
 */
const Borderless = exports.Borderless = {
  name: "Borderless",
  args: {
    borderless: true,
    children: "Only 8GB storage remaining.",
    severity: "caution",
    title: "Warning"
  }
};

/**
 * Actions will appear below the notification message.
 */
const Actions = exports.Actions = {
  name: "Actions",
  args: {
    actions: [{
      label: "Action 1",
      onClick: () => null
    }, {
      label: "Action 2",
      onClick: () => null
    }],
    children: "Body lorem ipsum dolor sit amet consequiteor. Lorem ipsum dolor sit amet consequiteor.",
    severity: "information",
    title: "Title"
  }
};

/**
 * Notifications that can be dismissed should be given an onDismiss function.
 */
const Dismissible = exports.Dismissible = {
  render: () => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const [show, setShow] = (0, _react.useState)(true);
    if (!show) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Notification.default, {
      onDismiss: () => setShow(false),
      title: "Dismissible"
    }, "Click the dismiss button to get rid of me.");
  },
  name: "Dismissible"
};

/**
 * Notifications can be automatically dismissed after a timeout interval.
 */
const Timeout = exports.Timeout = {
  render: () => {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const [show, setShow] = (0, _react.useState)(true);
    // eslint-disable-next-line react-hooks/rules-of-hooks
    const [timer, setTimer] = (0, _react.useState)(0);
    if (!show) {
      return null;
    }
    return /*#__PURE__*/_react.default.createElement(_Notification.default, {
      actions: [{
        label: "Start timer",
        onClick: () => setTimer(3000)
      }],
      onDismiss: () => setShow(false),
      timeout: timer,
      title: "Timeout"
    }, "Click the action to start a 3 second timer.");
  },
  name: "Timeout"
};

/**
 * For notifications in which recency is important, you can include a section for time.
 */
const Timestamp = exports.Timestamp = {
  name: "Timestamp",
  args: {
    children: "Body lorem ipsum dolor sit amet consequiteor. Lorem ipsum dolor sit amet consequiteor.",
    severity: "information",
    timestamp: "1h ago",
    title: "Title"
  }
};