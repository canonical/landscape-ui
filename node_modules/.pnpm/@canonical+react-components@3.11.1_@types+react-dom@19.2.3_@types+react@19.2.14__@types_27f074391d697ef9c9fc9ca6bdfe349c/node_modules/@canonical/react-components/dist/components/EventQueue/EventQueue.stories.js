"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _EventQueue = require("./EventQueue");
var _Button = _interopRequireDefault(require("../Button/Button"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const {
  EventQueueProvider,
  useEventQueue
} = (0, _EventQueue.createEventQueue)();
const meta = {
  title: "Components/EventQueue",
  component: EventQueueProvider,
  tags: ["autodocs"],
  parameters: {
    docs: {
      description: {
        component: "\nThis provides an event queue system for managing callbacks associated with\nasynchronous operations (e.g., API calls) in an application.\n\nIt allows components to register success, failure,\nand optional finish handlers for a given operation ID, and later retrieve or remove them.\n\nThis is useful for handling side effects when dealing\nwith multiple operations that need to be tracked and updated independently.\n\nThe `createEventQueue` function should be used to create a single provider and context that are shared throughout your application.\nThe returned `EventQueueProvider` and `useEventQueue` hook should be exported\nfrom a shared module and reused across the app to ensure a single\ncontext instance is used.\n\n**Usage pattern:**\n\n```tsx\n// eventQueue.ts\nexport const { EventQueueProvider, useEventQueue } = createEventQueue<EventType>();\n\n// App.tsx\nimport { EventQueueProvider } from \"./eventQueue\";\n\n<EventQueueProvider>\n  <App />\n</EventQueueProvider>\n\n// In any other component\nimport { useEventQueue } from \"./eventQueue\";\n\nconst eventQueue = useEventQueue();\neventQueue.set(operationId, onSuccess, onFailure);\n```"
      }
    }
  },
  decorators: [Story => /*#__PURE__*/_react.default.createElement(EventQueueProvider, null, /*#__PURE__*/_react.default.createElement(Story, null))]
};
var _default = exports.default = meta;
const Default = exports.Default = {
  render: () => {
    const EventQueueDemo = () => {
      const queue = useEventQueue();
      const operationId = "storybook-op-id";
      const [logs, setLogs] = (0, _react.useState)([]);
      const [isRegistered, setIsRegistered] = (0, _react.useState)(false);
      const appendLog = msg => setLogs(prev => [...prev, msg]);

      // This simulates the code that is executed when the asynchronous operation starts
      const register = () => {
        queue.set(operationId, event => appendLog("Success: ".concat(event.message)), msg => appendLog("Failure: ".concat(msg)), () => appendLog("Finished"));
        appendLog("Registered callbacks");
        setIsRegistered(true);
      };

      // This simulates the code that is executed when the asynchronous operation succeeds
      const triggerSuccess = () => {
        const event = queue.get(operationId);
        if (event) {
          var _event$onFinish;
          event.onSuccess({
            message: "This was successful!"
          });
          (_event$onFinish = event.onFinish) === null || _event$onFinish === void 0 || _event$onFinish.call(event);
          queue.remove(operationId);
          setIsRegistered(false);
        }
      };

      // This simulates the code that is executed when the asynchronous operation fails
      const triggerFailure = () => {
        const event = queue.get(operationId);
        if (event) {
          var _event$onFinish2;
          event.onFailure("Something failed!");
          (_event$onFinish2 = event.onFinish) === null || _event$onFinish2 === void 0 || _event$onFinish2.call(event);
          queue.remove(operationId);
          setIsRegistered(false);
        }
      };
      return /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", {
        style: {
          marginBottom: "0.5rem",
          display: "flex"
        }
      }, /*#__PURE__*/_react.default.createElement(_Button.default, {
        onClick: register,
        disabled: isRegistered
      }, "Register Callbacks"), /*#__PURE__*/_react.default.createElement(_Button.default, {
        onClick: triggerSuccess,
        disabled: !isRegistered
      }, "Trigger Success"), /*#__PURE__*/_react.default.createElement(_Button.default, {
        onClick: triggerFailure,
        disabled: !isRegistered
      }, "Trigger Failure")), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("strong", null, "Logs:"), /*#__PURE__*/_react.default.createElement("ul", null, logs.map((log, index) => /*#__PURE__*/_react.default.createElement("li", {
        key: index
      }, log)))));
    };
    return /*#__PURE__*/_react.default.createElement(EventQueueDemo, null);
  }
};