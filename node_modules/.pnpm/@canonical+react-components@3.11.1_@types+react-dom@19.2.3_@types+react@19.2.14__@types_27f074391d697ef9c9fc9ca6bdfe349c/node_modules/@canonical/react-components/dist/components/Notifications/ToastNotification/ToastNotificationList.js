"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.severityOrder = exports.iconLookup = exports.default = void 0;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _Button = _interopRequireDefault(require("../../Button"));
var _Icon = _interopRequireWildcard(require("../../Icon"));
var _Notification = _interopRequireDefault(require("../Notification"));
var _Notification2 = require("../Notification/Notification");
var _react = _interopRequireWildcard(require("react"));
var _reactDom = require("react-dom");
var _Animate = _interopRequireDefault(require("./Animate"));
var _hooks = require("../../../hooks");
require("./Toast.scss");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const severityOrder = exports.severityOrder = ["positive", "caution", "negative", "information"];
const iconLookup = exports.iconLookup = {
  positive: _Icon.ICONS.success,
  information: _Icon.ICONS.information,
  caution: _Icon.ICONS.warning,
  negative: _Icon.ICONS.error
};
const ToastNotificationList = _ref => {
  let {
    notifications,
    onDismiss,
    groupedCount = {},
    show
  } = _ref;
  const [filters, setFilters] = (0, _react.useState)(new Set());
  const prevNotificationsSize = (0, _react.useRef)(notifications.length);
  const containerRef = (0, _react.useRef)(null);
  const hasFilters = !!filters.size;
  const preferReducedMotion = (0, _hooks.usePrefersReducedMotion)();
  (0, _react.useLayoutEffect)(() => {
    adjustScrollPosition();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [notifications]);

  // this layout effect is used to maintain scroll position of the
  // notification list when new notifications are added to the list
  // for only when the scroll is at the top
  const adjustScrollPosition = () => {
    const notificationsRemoved = notifications.length < prevNotificationsSize.current;
    prevNotificationsSize.current = notifications.length;
    if (!notifications.length || notificationsRemoved) {
      return;
    }
    const container = containerRef.current;
    const lastNotification = notifications[notifications.length - 1];
    const notificationEl = document.getElementById(lastNotification.id);
    if (container && notificationEl) {
      const currentScrollY = container.scrollTop;
      const offsetHeight = notificationEl.getBoundingClientRect().height + parseFloat(window.getComputedStyle(notificationEl).marginTop) + parseFloat(window.getComputedStyle(notificationEl).marginBottom);
      // only adjust the scroll height if the scroll is at the top
      if (currentScrollY === 0) {
        container.scrollTop = currentScrollY + offsetHeight;
      }
    }
  };
  const handleFilterSelect = filter => {
    setFilters(prevFilters => {
      const newFilters = new Set(prevFilters);
      if (!newFilters.has(filter)) {
        newFilters.add(filter);
      } else {
        newFilters.delete(filter);
      }
      return newFilters;
    });
  };
  const handleGroupedDismiss = () => {
    if (hasFilters) {
      const notificationsToClear = notifications.filter(notification => filters.has(notification.type));
      onDismiss(notificationsToClear);
      setFilters(new Set());
      return;
    }
    onDismiss(notifications);
  };
  const getSeverityFilters = () => {
    const filterButtons = severityOrder.map(severity => {
      if (groupedCount[severity]) {
        return /*#__PURE__*/_react.default.createElement("button", {
          "aria-label": "Filter ".concat(severity, " notifications"),
          "aria-pressed": filters.has(severity),
          key: severity,
          className: "u-no-margin u-no-border filter-button",
          onClick: () => {
            handleFilterSelect(severity);
          }
        }, /*#__PURE__*/_react.default.createElement(_Icon.default, {
          name: iconLookup[severity]
        }), /*#__PURE__*/_react.default.createElement("span", null, groupedCount[severity]));
      }
      return null;
    });
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "filters"
    }, filterButtons, hasFilters && /*#__PURE__*/_react.default.createElement("button", {
      className: "u-no-margin--bottom u-no-border",
      onClick: () => {
        setFilters(new Set());
      }
    }, "Clear filters"));
  };
  const getDismissText = () => {
    if (hasFilters) {
      const validFilters = Object.keys(groupedCount);
      let totalCount = 0;
      for (const filter of validFilters) {
        if (filters.has(filter)) {
          totalCount += groupedCount[filter] || 0;
        }
      }
      const dismissText = /*#__PURE__*/_react.default.createElement("span", {
        className: "dismiss-text"
      }, "Dismiss ", totalCount);
      return dismissText;
    }
    return /*#__PURE__*/_react.default.createElement("span", null, "Dismiss all");
  };
  const handleDismissNotification = notification => {
    if (preferReducedMotion) {
      onDismiss([notification]);
      return;
    }

    // animate the notification dismissal before updating states to delay unmounting
    const element = document.getElementById("li-".concat(notification.id));
    if (element) {
      element.style.transformOrigin = "center";
      element.style.overflow = "hidden";
      const animation = element.animate([{
        height: "".concat(element.scrollHeight, "px"),
        opacity: 1
      }, {
        height: "0px",
        opacity: 0
      }], {
        duration: 200,
        easing: "linear",
        fill: "forwards"
      });
      animation.onfinish = () => {
        element.style.display = "none";
        onDismiss([notification]);
      };
    }
  };

  // Only filter input data if there are filters present
  const filteredNotifications = hasFilters ? notifications.filter(notification => filters.has(notification.type)) : notifications;
  (0, _react.useEffect)(() => {
    if (hasFilters && filteredNotifications.length === 0) {
      // if there are no filtered notifications, reset the filters
      setFilters(new Set());
    }
  }, [hasFilters, filteredNotifications]);

  // Don't assign alert role for notifications when expanded since we don't want
  // screen readers to announce every existing notification
  const notificationEls = filteredNotifications.map((_, index, array) => {
    var _notification$title;
    const lastNotificationIndex = array.length - 1;
    // This will map notifications in reverse order
    const notification = array[lastNotificationIndex - index];
    return /*#__PURE__*/_react.default.createElement("li", {
      key: notification.id,
      id: "li-".concat(notification.id)
    }, /*#__PURE__*/_react.default.createElement(_Notification.default, {
      id: notification.id,
      title: (_notification$title = notification.title) !== null && _notification$title !== void 0 ? _notification$title : _Notification2.DefaultTitles[notification.type],
      actions: notification.actions,
      severity: notification.type,
      onDismiss: () => {
        handleDismissNotification(notification);
      },
      className: "u-no-margin--bottom individual-notification",
      timestamp: notification.timestamp,
      titleElement: "div"
    }, notification.message));
  });
  return /*#__PURE__*/(0, _reactDom.createPortal)( /*#__PURE__*/_react.default.createElement(_Animate.default, {
    show: show,
    from: {
      opacity: 0,
      transform: "translateY(5vh)"
    },
    to: {
      opacity: 1,
      transform: "translateY(0)"
    },
    options: {
      duration: 100
    },
    className: "toast-animate"
  }, /*#__PURE__*/_react.default.createElement("ul", {
    className: "toast-notification-list",
    "aria-label": "Notifications list",
    ref: containerRef
  }, notificationEls, /*#__PURE__*/_react.default.createElement("li", {
    className: "dismiss"
  }, getSeverityFilters(), /*#__PURE__*/_react.default.createElement(_Button.default, {
    className: "u-no-margin--bottom dismiss-button",
    onClick: handleGroupedDismiss,
    hasIcon: true
  }, /*#__PURE__*/_react.default.createElement(_Icon.default, {
    name: "tidy"
  }), getDismissText())))), document.body);
};
ToastNotificationList.propTypes = {
  notifications: _propTypes.default.array.isRequired,
  onDismiss: _propTypes.default.func.isRequired,
  show: _propTypes.default.bool.isRequired
};
var _default = exports.default = ToastNotificationList;