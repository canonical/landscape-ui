"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useToastNotification = exports.default = void 0;
var _NotificationProvider = require("../../NotificationProvider");
var _ToastNotification = _interopRequireDefault(require("./ToastNotification"));
var _ToastNotificationList = _interopRequireDefault(require("./ToastNotificationList"));
var _react = _interopRequireWildcard(require("react"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const HIDE_NOTIFICATION_DELAY = 5000;
const initialNotification = {
  id: "",
  message: "",
  type: "positive"
};
const ToastNotificationContext = /*#__PURE__*/(0, _react.createContext)({
  /** List of all active toast notifications */
  notifications: [],
  /** Show a success toast. Optionally pass actions and a title. */
  success: () => initialNotification,
  /** Show an info toast. Optionally pass a custom title and actions. */
  info: () => initialNotification,
  /** Show a failure toast with an error and optional message/actions. */
  failure: () => initialNotification,
  /** Show a caution toast. Optionally pass actions and a title. */
  caution: () => initialNotification,
  /** Clear one or more specific toasts, or all if none provided. */
  clear: () => null,
  /** Toggle between single toast view and list view. */
  toggleListView: () => null,
  /** Whether the notification list view is currently open. */
  isListView: false,
  /** Grouped count of notifications by severity (positive, info, etc.). */
  countBySeverity: {}
});

/**
 * The `ToastNotificationProvider` can be used to manage toast notifications.

Wrap your application with this provider, and in any child component you can get the helper with `const toastNotify = useToastNotification()` to trigger notifications.
Notifications automatically dismiss after a delay unless manually dismissed or expanded.

To make the notification persistent (i.e., not auto-dismiss), set the `autoDismissDelay` prop to `0` when using the provider: `<ToastNotificationProvider autoDismissDelay={0}>`

| **Values**                       | **Description**                                                                |
|----------------------------------|--------------------------------------------------------------------------------|
| `toastNotify.success()`          | Displays a success toast. Optionally accepts actions and a title.              |
| `toastNotify.info()`             | Displays an info toast. Optionally accepts a custom title.                     |
| `toastNotify.failure()`          | Displays a failure toast with an error and optional message or actions.        |
| `toastNotify.caution()`          | Displays a caution toast. Optionally accepts actions and a title.              |
| `toastNotify.clear()`            | Clears specific toasts, or all toasts if none are specified.                   |
| `toastNotify.toggleListView()`   | Toggles the notification list view open or closed.                             |
| `toastNotify.countBySeverity`    | Returns the count of notifications grouped by severity (e.g., success, info).  |

Some example usages:

1. **Show a success toast:**
```
toastNotify.success("Your changes have been saved.");
toastNotify.success("Your changes have been saved.", [{label: "Undo", onClick: () => console.log("Undo clicked")}]);
```

2. **Show an info toast:**
```
toastNotify.info("Your changes are syncing in the background.");
toastNotify.info("Your changes are syncing in the background.", "Syncing");
```

3. **Show a failure toast:**
```
toastNotify.failure("Save failed", new Error("500 Internal Server Error"), "Please try again.");
toastNotify.failure("Save failed", new Error("500 Internal Server Error"), "Please try again.", [{label: "Retry", onClick: () => console.log("Retry clicked")}]);
```

4. **Show a caution toast:**
```
toastNotify.caution("Your changes have not been saved.");
toastNotify.caution("Your changes have not been saved.", [{label: "Undo", onClick: () => console.log("Undo clicked")}]);
```

5. **Clear notifications:**
```
toastNotify.clear(); // clears all toast notifications
toastNotify.clear([notificationId]); // clears specific toast notifications
```

6. **Toggle the notification list view:**
```
toastNotify.toggleListView();
```

7. **Get the count of notifications by severity:**
```
const count = toastNotify.countBySeverity;
console.log(count.positive);
```

Alternatively, you can use the `ToastNotification` and `ToastNotificationList` components directly, without using the provider.
*/

const ToastNotificationProvider = _ref => {
  let {
    children,
    onDismiss,
    autoDismissDelay = HIDE_NOTIFICATION_DELAY
  } = _ref;
  const [notifications, setNotifications] = (0, _react.useState)([]);
  const [showList, setShowList] = (0, _react.useState)(false);
  const [notificationTimer, setNotificationTimer] = (0, _react.useState)(null);

  // cleanup on timer if unmounted
  (0, _react.useEffect)(() => {
    return () => {
      if (notificationTimer && typeof notificationTimer !== "boolean") {
        clearTimeout(notificationTimer);
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const showNotificationWithDelay = () => {
    setNotificationTimer(prevTimer => {
      if (prevTimer && typeof prevTimer !== "boolean") {
        clearTimeout(prevTimer);
      }
      if (!showList) {
        // If autoDismissDelay is 0, make notification persistent (no auto-hide)
        if (!autoDismissDelay) {
          return true; // Set a truthy value to indicate notification should show
        }
        return setTimeout(() => {
          setNotificationTimer(null);
        }, autoDismissDelay);
      }
      return null;
    });
  };
  const clearNotificationTimer = () => {
    setNotificationTimer(prevTimer => {
      if (prevTimer && typeof prevTimer !== "boolean") {
        clearTimeout(prevTimer);
      }
      return null;
    });
  };
  const pauseTimer = () => {
    if (notificationTimer && typeof notificationTimer !== "boolean") {
      clearTimeout(notificationTimer);
      setNotificationTimer(true); // mark as paused
    }
  };
  const resumeTimer = () => {
    if (notificationTimer === true) {
      // only resume if previously paused
      showNotificationWithDelay();
    }
  };
  const addNotification = notification => {
    var _notification$id;
    const notificationToAdd = _objectSpread(_objectSpread({}, notification), {}, {
      timestamp: new Date().toLocaleString(),
      id: (_notification$id = notification.id) !== null && _notification$id !== void 0 ? _notification$id : Date.now().toString() + (Math.random() + 1).toString(36).substring(7)
    });
    setNotifications(prev => {
      return [...prev, notificationToAdd];
    });
    showNotificationWithDelay();
    return notificationToAdd;
  };
  const clear = notifications => {
    if (onDismiss) {
      onDismiss(notifications);
    }
    if (!notifications) {
      setNotifications([]);
      setShowList(false);
      clearNotificationTimer();
      return;
    }
    setNotifications(prev => {
      const removeIdLookup = new Set(notifications);
      const newNotifications = prev.filter(item => !removeIdLookup.has(item));

      // if we are clearing the last notification from an expanded list,
      // then we want to collapse the list as well if all notifications has been cleared
      if (!newNotifications.length) {
        setShowList(false);
      }
      return newNotifications;
    });
    clearNotificationTimer();
  };
  const toggleListView = () => {
    clearNotificationTimer();
    setShowList(prev => !prev);
  };
  const countBySeverity = {
    positive: 0,
    negative: 0,
    caution: 0,
    information: 0
  };
  notifications.forEach(notification => {
    countBySeverity[notification.type] += 1;
  });
  const helper = {
    notifications,
    failure: (title, error, message, actions, id) => addNotification(_objectSpread(_objectSpread({}, (0, _NotificationProvider.failure)(title, error, message, actions)), {}, {
      id
    })),
    info: (message, title, actions, id) => addNotification(_objectSpread(_objectSpread({}, (0, _NotificationProvider.info)(message, title, actions)), {}, {
      id
    })),
    success: (message, actions, title, id) => addNotification(_objectSpread(_objectSpread({}, (0, _NotificationProvider.success)(message, title, actions)), {}, {
      id
    })),
    caution: (message, actions, title, id) => addNotification(_objectSpread(_objectSpread({}, (0, _NotificationProvider.caution)(message, title, actions)), {}, {
      id
    })),
    clear,
    toggleListView,
    isListView: showList,
    countBySeverity
  };
  const latestNotification = notifications[notifications.length - 1];
  const hasNotifications = !!notifications.length;
  const showNotification = hasNotifications && !showList && notificationTimer;
  const showNotificationList = hasNotifications && showList;
  return /*#__PURE__*/_react.default.createElement(ToastNotificationContext.Provider, {
    value: helper
  }, children, /*#__PURE__*/_react.default.createElement(_ToastNotification.default, {
    notification: latestNotification,
    onDismiss: clear,
    show: !!showNotification,
    onHoverStart: pauseTimer,
    onHoverEnd: resumeTimer
  }), /*#__PURE__*/_react.default.createElement(_ToastNotificationList.default, {
    notifications: notifications,
    groupedCount: countBySeverity,
    show: showNotificationList,
    onDismiss: clear
  }));
};
var _default = exports.default = ToastNotificationProvider;
const useToastNotification = () => (0, _react.useContext)(ToastNotificationContext);
exports.useToastNotification = useToastNotification;