"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SUCCESS_DURATION = exports.Label = exports.LOADER_MIN_DURATION = void 0;
var _classnames = _interopRequireDefault(require("classnames"));
var _react = _interopRequireWildcard(require("react"));
var _Icon = _interopRequireDefault(require("../Icon"));
const _excluded = ["appearance", "children", "className", "onClick", "disabled", "inline", "loading", "success"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
const LOADER_MIN_DURATION = exports.LOADER_MIN_DURATION = 400; // minimium duration (ms) loader displays
const SUCCESS_DURATION = exports.SUCCESS_DURATION = 2000; // duration (ms) success tick is displayed
let Label = exports.Label = /*#__PURE__*/function (Label) {
  Label["WAITING"] = "Waiting for action to complete";
  Label["SUCCESS"] = "Action completed";
  return Label;
}({});
/**
 * This is a not an existing Vanilla component. It can be used to display submitting states for forms or other actions.
 *
 * ActionButton accepts the props from
 * [Button](?path=/docs/components-button--docs) in addition to those in the
 * props table:
 */
const ActionButton = _ref => {
  let {
      appearance,
      children,
      className,
      onClick,
      disabled = null,
      inline = false,
      loading = false,
      success = false
    } = _ref,
    buttonProps = _objectWithoutProperties(_ref, _excluded);
  const [height, setHeight] = (0, _react.useState)();
  const [width, setWidth] = (0, _react.useState)();
  const [showLoader, setShowLoader] = (0, _react.useState)(false);
  const [showSuccess, setShowSuccess] = (0, _react.useState)(false);
  const ref = (0, _react.useRef)(null);
  const startLoadTime = (0, _react.useRef)(undefined);

  // Set up loader timer
  (0, _react.useEffect)(() => {
    let loaderTimeout;
    if (loading) {
      // add a condition to prevent double set startLoadTime
      // when showLoader changes.
      if (startLoadTime.current === undefined) {
        // Keep track of the time when loading starts
        startLoadTime.current = new Date();
      }
      // Explicitly set button dimensions
      if (ref.current && !!ref.current.getBoundingClientRect()) {
        setHeight(ref.current.getBoundingClientRect().height);
        setWidth(ref.current.getBoundingClientRect().width);
      }
      setShowLoader(true);
    }
    if (!loading && showLoader) {
      var _startLoadTime$curren;
      const now = new Date();
      // calculate elapsed loading time
      const loadingMilliseconds = now.getTime() - ((_startLoadTime$curren = startLoadTime.current) !== null && _startLoadTime$curren !== void 0 ? _startLoadTime$curren : now).getTime();

      // and subtract it from LOADER_MIN_DURATION,

      // also add an edge case when time diff is less than 0 to be 0.
      const timeoutDuration = Math.max(LOADER_MIN_DURATION - loadingMilliseconds, 0);
      const loadFinishHandler = () => {
        startLoadTime.current = undefined;
        setShowLoader(false);
        if (success) {
          setShowSuccess(true);
        }
      };
      if (timeoutDuration > 0) {
        loaderTimeout = window.setTimeout(loadFinishHandler, timeoutDuration);
      } else {
        loadFinishHandler();
      }
    }
    if (!loading && !showLoader) {
      setHeight(null);
      setWidth(null);
    }
    return () => window.clearTimeout(loaderTimeout);
  }, [loading, showLoader, success]);

  // Set up success timer
  (0, _react.useEffect)(() => {
    let successTimeout;
    if (showSuccess) {
      successTimeout = window.setTimeout(() => {
        setHeight(null);
        setWidth(null);
        setShowSuccess(false);
      }, SUCCESS_DURATION);
    }
    return () => window.clearTimeout(successTimeout);
  }, [showSuccess]);
  const buttonClasses = (0, _classnames.default)(className, "p-action-button", appearance ? "p-button--".concat(appearance) : "p-button", {
    "is-processing": showLoader || showSuccess,
    "is-disabled": disabled === null ? showLoader : disabled,
    "is-inline": inline
  });
  const showIcon = showLoader || showSuccess;
  const isDisabled = disabled === null ? showLoader : disabled;
  const icon = showLoader && "spinner" || showSuccess && "success" || null;
  const iconLight = appearance === "positive" || appearance === "negative";
  const onClickDisabled = e => e.preventDefault();

  // This component uses the base button element instead of the Button component
  // as the button requires a ref and Button would have to be updated to use
  // forwardRef which is not currently supported by components that use
  // typescript generics.
  return /*#__PURE__*/_react.default.createElement("button", _extends({
    className: buttonClasses,
    ref: ref,
    onClick: isDisabled ? onClickDisabled : onClick,
    "aria-disabled": isDisabled || undefined,
    style: height && width ? {
      height: "".concat(height, "px"),
      width: "".concat(width, "px")
    } : undefined
  }, buttonProps), showIcon ? /*#__PURE__*/_react.default.createElement(_Icon.default, {
    "aria-label": showLoader ? Label.WAITING : Label.SUCCESS,
    className: showLoader ? "u-animation--spin" : null,
    light: iconLight,
    name: icon
  }) : children);
};
var _default = exports.default = ActionButton;