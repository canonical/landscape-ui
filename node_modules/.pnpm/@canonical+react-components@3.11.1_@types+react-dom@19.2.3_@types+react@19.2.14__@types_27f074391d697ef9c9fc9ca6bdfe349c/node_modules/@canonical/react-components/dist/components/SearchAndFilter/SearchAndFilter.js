"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Label = void 0;
var _propTypes = _interopRequireDefault(require("prop-types"));
var _react = _interopRequireWildcard(require("react"));
var _FilterPanelSection = _interopRequireDefault(require("./FilterPanelSection"));
var _Chip = _interopRequireDefault(require("../Chip"));
var _utils = require("./utils");
var _hooks = require("../../hooks");
const _excluded = ["existingSearchData", "filterPanelData", "returnSearchData", "onPanelToggle", "onExpandChange"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
let Label = exports.Label = /*#__PURE__*/function (Label) {
  Label["AddFilter"] = "Add filter";
  Label["Clear"] = "Clear input";
  Label["SearchAndFilter"] = "Search and filter";
  return Label;
}({});
/**
 * This component allows searching and filtering of large datasets.
 */
const SearchAndFilter = _ref => {
  let {
      existingSearchData = [],
      filterPanelData,
      returnSearchData,
      onPanelToggle = () => {},
      onExpandChange = () => {}
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  const [searchData, setSearchData] = (0, _react.useState)(existingSearchData);
  const [searchTerm, setSearchTerm] = (0, _react.useState)("");
  const [filterPanelHidden, setFilterPanelHidden] = (0, _react.useState)(true);
  const [searchBoxExpanded, setSearchBoxExpanded] = (0, _react.useState)(false);
  const [overflowSearchTermCounter, setOverflowSearchTermCounter] = (0, _react.useState)(0);
  const [searchContainerActive, setSearchContainerActive] = (0, _react.useState)(false);
  const [maxHeight, setMaxHeight] = (0, _react.useState)();
  const searchAndFilterRef = (0, _react.useRef)(null);
  const searchContainerRef = (0, _react.useRef)(null);
  const searchBoxRef = (0, _react.useRef)(null);
  const panel = (0, _react.useRef)(null);

  // Call onPanelToggle when the filterPanelHidden state changes
  (0, _react.useEffect)(onPanelToggle, [onPanelToggle, filterPanelHidden]);

  // Call onExpandChange when the search box is expanded or collapsed
  (0, _react.useEffect)(onExpandChange, [onExpandChange, searchBoxExpanded]);

  // Return searchData to parent component
  (0, _react.useEffect)(() => {
    let mounted = true;
    returnSearchData && mounted && returnSearchData(searchData);
    return () => {
      mounted = false;
    };
  }, [searchData, returnSearchData]);

  // Hide manual input form field when search container is inactive
  (0, _react.useEffect)(() => {
    const searchContainerClickCheck = e => {
      var _e$target;
      const clickInContainer = ((_e$target = e.target) === null || _e$target === void 0 ? void 0 : _e$target.closest(".p-search-and-filter")) !== null;
      setSearchContainerActive(clickInContainer);
    };
    document.addEventListener("click", searchContainerClickCheck);
    return () => {
      document.removeEventListener("click", searchContainerClickCheck);
    };
  }, [searchContainerActive]);
  const closePanel = () => {
    setFilterPanelHidden(true);
  };
  (0, _hooks.useOnEscapePressed)(() => closePanel());

  // This useEffect sets up listeners so the panel will close if user clicks
  // anywhere else on the page or hits the escape key
  (0, _react.useEffect)(() => {
    const mouseDown = e => {
      var _searchAndFilterRef$c;
      // Check if click is outside of filter panel
      if (!(searchAndFilterRef !== null && searchAndFilterRef !== void 0 && (_searchAndFilterRef$c = searchAndFilterRef.current) !== null && _searchAndFilterRef$c !== void 0 && _searchAndFilterRef$c.contains(e.target))) {
        // If so, close the panel
        closePanel();
      }
    };

    // Add listener on document to capture click events
    document.addEventListener("mousedown", mouseDown);
    // return function to be called when unmounted
    return () => {
      document.removeEventListener("mousedown", mouseDown);
    };
  }, []);

  // Add passed chip to the searchData array
  const toggleSelected = chip => {
    const currentSelected = [...searchData];
    if (!(0, _utils.isChipInArray)(chip, currentSelected)) {
      currentSelected.push(chip);
      setSearchData(currentSelected);
      setSearchTerm("");
    } else {
      const updatedCurrentSelected = currentSelected.filter(currentSelectedChip => {
        return currentSelectedChip.value !== chip.value;
      });
      setSearchData(updatedCurrentSelected);
    }
  };

  // Remove passed chip from the searchData array
  const removeFromSelected = chip => {
    if (searchData.includes(chip)) {
      const updatedSelected = searchData.filter(searchDataChip => searchDataChip !== chip);
      setSearchData(updatedSelected);
    }
  };

  // When overflow chips are shown, clicking anywhere outside search area
  // or clicking on a chip should hide them again
  (0, _react.useEffect)(() => {
    const hideOverflowChips = e => {
      if (!e.target.closest(".p-search-and-filter") && e.target.className !== "p-icon--close") {
        setSearchBoxExpanded(false);
      }
    };
    document.addEventListener("click", e => {
      hideOverflowChips(e);
    });
    return () => {
      document.removeEventListener("click", e => {
        hideOverflowChips(e);
      });
    };
  }, []);
  const handleSubmit = () => {
    if (searchTerm.trim() !== "") {
      toggleSelected({
        value: searchTerm,
        quoteValue: true
      });
      setSearchTerm("");
    }
  };

  // If the offsetTop is more than double height of a single chip, consider it
  // overflowing
  const updateFlowCount = function () {
    var _searchContainerRef$c;
    const chips = searchContainerRef === null || searchContainerRef === void 0 || (_searchContainerRef$c = searchContainerRef.current) === null || _searchContainerRef$c === void 0 ? void 0 : _searchContainerRef$c.querySelectorAll(".p-chip");
    const overflowCount = (0, _utils.overflowingChipsCount)(chips, 1);
    setOverflowSearchTermCounter(overflowCount);
  };

  // Watch for container resize and recalculate overflow count accordingly
  (0, _react.useEffect)(() => {
    const resizeObserverSupported = typeof ResizeObserver !== "undefined";
    const wrapper = searchContainerRef.current;
    let wrapperWidthObserver;
    if (resizeObserverSupported && wrapper) {
      wrapperWidthObserver = new ResizeObserver(() => {
        updateFlowCount();
      });
      wrapperWidthObserver.observe(wrapper);
    } else {
      updateFlowCount();
    }
    return () => {
      var _wrapperWidthObserver;
      resizeObserverSupported && ((_wrapperWidthObserver = wrapperWidthObserver) === null || _wrapperWidthObserver === void 0 ? void 0 : _wrapperWidthObserver.disconnect());
    };
  }, [searchData]);
  (0, _hooks.useWindowFitment)(panel.current, searchAndFilterRef.current, fitsWindow => setMaxHeight(fitsWindow.fromBottom.spaceBelow - 16), 0, !filterPanelHidden);

  // Add search prompt value to search on Enter key
  const searchPromptKeyDown = e => {
    if (e.key === "Enter") {
      handleSubmit();
    }
  };
  const searchBox = searchBoxRef.current;
  const searchContainer = searchContainerRef.current;
  if (!searchBoxExpanded && searchBox && searchContainer && overflowSearchTermCounter === 0) {
    if (searchBox.offsetTop > searchContainer.offsetHeight) {
      setSearchBoxExpanded(true);
    }
  }

  // If chips or input field contains values, clear 'em out
  const clearAllSearchTerms = () => {
    setSearchTerm("");
  };
  const placeholder = searchData.length ? Label.AddFilter : Label.SearchAndFilter;
  return /*#__PURE__*/_react.default.createElement("div", _extends({
    className: "p-search-and-filter",
    ref: searchAndFilterRef,
    onClick: () => filterPanelHidden && setFilterPanelHidden(false)
  }, props), /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__search-container",
    "aria-expanded": searchBoxExpanded,
    "data-active": searchContainerActive || searchData.length === 0,
    "data-empty": searchData.length <= 0,
    ref: searchContainerRef
  }, searchTerm !== "" && /*#__PURE__*/_react.default.createElement("button", {
    "aria-label": Label.Clear,
    className: "p-search-and-filter__clear",
    onClick: () => clearAllSearchTerms()
  }, /*#__PURE__*/_react.default.createElement("i", {
    className: "p-icon--close"
  })), Object.values(searchData).map(chip => {
    return /*#__PURE__*/_react.default.createElement(_Chip.default, {
      lead: chip.lead,
      value: chip.value,
      key: "search-".concat(chip.lead, "+").concat(chip.value),
      onDismiss: event => {
        // Prevent filter chip dismissals from bubbling up and triggering the parent onClick handler
        event.stopPropagation();
        removeFromSelected(chip);
      },
      selected: true,
      quoteValue: chip.quoteValue
    });
  }), /*#__PURE__*/_react.default.createElement("form", {
    className: "p-search-and-filter__box",
    onSubmit: e => {
      e.preventDefault();
      handleSubmit();
    },
    "data-overflowing": searchBoxExpanded,
    ref: searchBoxRef
  }, /*#__PURE__*/_react.default.createElement("label", {
    className: "u-off-screen",
    htmlFor: "search-and-filter-input"
  }, searchData.length ? Label.AddFilter : Label.SearchAndFilter), /*#__PURE__*/_react.default.createElement("input", {
    autoComplete: "off",
    className: "p-search-and-filter__input",
    id: "search-and-filter-input",
    name: "search",
    onChange: e => setSearchTerm(e.target.value),
    placeholder: placeholder,
    type: "search",
    value: searchTerm
  }), /*#__PURE__*/_react.default.createElement("button", {
    className: "u-off-screen",
    type: "submit"
  }, "Search")), overflowSearchTermCounter > 0 && /*#__PURE__*/_react.default.createElement("span", {
    className: "p-search-and-filter__selected-count",
    onClick: () => setSearchBoxExpanded(true),
    onKeyDown: () => setSearchBoxExpanded(true),
    role: "button",
    tabIndex: 0
  }, "+", overflowSearchTermCounter)), (filterPanelData.length > 0 || searchTerm.length > 0) && /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__panel",
    "aria-hidden": filterPanelHidden,
    ref: panel,
    style: {
      maxHeight,
      minHeight: "5rem",
      overflowX: "auto"
    }
  }, /*#__PURE__*/_react.default.createElement("div", null, searchTerm.length > 0 && /*#__PURE__*/_react.default.createElement("div", {
    className: "p-search-and-filter__search-prompt",
    onClick: () => handleSubmit(),
    onKeyDown: e => searchPromptKeyDown(e),
    role: "button",
    tabIndex: 0
  }, "Search for", " ", /*#__PURE__*/_react.default.createElement("span", {
    className: "p-search-and-filter__search-query"
  }, searchTerm), "..."), filterPanelData.map(filterPanelSectionData => {
    return /*#__PURE__*/_react.default.createElement(_FilterPanelSection.default, {
      key: filterPanelSectionData.id,
      data: filterPanelSectionData,
      toggleSelected: toggleSelected,
      searchData: searchData,
      searchTerm: searchTerm,
      sectionHidden: filterPanelHidden
    });
  }))));
};
SearchAndFilter.propTypes = {
  existingSearchData: _propTypes.default.array,
  filterPanelData: _propTypes.default.array.isRequired,
  returnSearchData: _propTypes.default.func.isRequired,
  onPanelToggle: _propTypes.default.func,
  onExpandChange: _propTypes.default.func
};
var _default = exports.default = SearchAndFilter;