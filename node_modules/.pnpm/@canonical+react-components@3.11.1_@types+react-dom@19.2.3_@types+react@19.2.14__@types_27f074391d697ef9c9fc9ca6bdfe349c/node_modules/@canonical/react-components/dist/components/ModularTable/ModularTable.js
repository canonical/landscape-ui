"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactTable = require("react-table");
var _Table = _interopRequireDefault(require("../Table"));
var _TableRow = _interopRequireDefault(require("../TableRow"));
var _TableHeader = _interopRequireDefault(require("../TableHeader"));
var _TableCell = _interopRequireDefault(require("../TableCell"));
var _Icon = _interopRequireDefault(require("../Icon"));
const _excluded = ["data", "columns", "emptyMsg", "footer", "sortable", "getHeaderProps", "getRowProps", "getCellProps", "getRowId", "initialSortColumn", "initialSortDirection", "autoResetSortBy", "subhead"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
const generateCell = (cell, getCellProps) => {
  var _cell$column$getCellI, _cell$column;
  const hasColumnIcon = cell.column.getCellIcon;
  const iconName = hasColumnIcon && ((_cell$column$getCellI = (_cell$column = cell.column).getCellIcon) === null || _cell$column$getCellI === void 0 ? void 0 : _cell$column$getCellI.call(_cell$column, cell));
  return /*#__PURE__*/_react.default.createElement(_TableCell.default, cell.getCellProps([{
    className: cell.column.className
  }, {
    className: hasColumnIcon ? "p-table__cell--icon-placeholder" : ""
  }, _objectSpread({}, getCellProps === null || getCellProps === void 0 ? void 0 : getCellProps(cell))]), iconName && /*#__PURE__*/_react.default.createElement(_Icon.default, {
    name: iconName
  }), cell.render("Cell"));
};
const generateRows = (rows, prepareRow, getRowProps, getCellProps) => {
  let tableRows = [];
  rows.forEach(row => {
    var _row$subRows;
    // This function is responsible for lazily preparing a row for rendering.
    // Any row that you intend to render in your table needs to be passed to this function before every render.
    // see: https://react-table.tanstack.com/docs/api/useTable#instance-properties
    prepareRow(row);
    tableRows.push( /*#__PURE__*/_react.default.createElement(_TableRow.default, row.getRowProps(getRowProps === null || getRowProps === void 0 ? void 0 : getRowProps(row)), row.cells.map(cell => generateCell(cell, getCellProps))));
    if ((_row$subRows = row.subRows) !== null && _row$subRows !== void 0 && _row$subRows.length) {
      tableRows = tableRows.concat(generateRows(row.subRows, prepareRow, getRowProps, getCellProps));
    }
  });
  return tableRows;
};

/**
This is a [React](https://reactjs.org/) component to support many table use cases.
 
ModularTable components accepts `columns` and `data` arguments in the same format as [`useTable`](https://react-table.tanstack.com/docs/api/useTable) hook of the ReactTable library.

`columns` - The core columns configuration object for the entire table. https://react-table.tanstack.com/docs/api/useTable#column-options
`data` - The data array that you want to display on the table.
### Important note!
Values passed to both of these params have to be memoized (for example via{" "}
  <code>React.useMemo</code>). Memoization ensures that our data isn't recreated
  on every render. If we didn't use <code>React.useMemo</code>, the table would
  think it was receiving new data on every render and attempt to recalulate a
  lot of logic every single time.

#### Custom column options

In addition to standard column propeties from [`useTable`](https://react-table.tanstack.com/docs/api/useTable) `ModularTable` accepts some custom properties.

##### Class names

Custom `className` can be used to provide a specific CSS class name that will be added to all cells in given column.
You can also provide `getHeaderProps`, `getRowProps` and `getCellProps` to resolve additional custom props for a specific element. More on this in [`useTable - cell properties`](https://react-table.tanstack.com/docs/api/useTable#cell-properties).

```js
getCellProps={({ value, column }) => ({
  className: `table__cell--${column.id} ${value ===  "1 minute" ? "p-heading--5" : ""}`,
})}
columns = {
  Header: "Hidden on mobile",
  accessor: "example",
  className: "u-hide--small"
}
```

##### Icons

To show an icon in the cells of a column `getCellIcon` function should be defined. The function takes a cell data as an argument and should return one of built in icons (from the `ICONS` const), a string with a custom icon name, or `false` if no icon should be shown.

The `ICONS` const contains all [the Vanilla built in icons](https://vanillaframework.io/docs/patterns/icons) such as "plus", "minus", "success", "error", etc.

Product specific icons can be used as well, assuming that the product provides the necessary CSS styling and the icon follows the Vanilla naming convention `p-icon--{name}`.

```js
columns = {
  Header: "With icons",
  accessor: "status",
  getCellIcon: ({ value }) => {
    return value === "released" ? ICONS.success : false;
  },
};
```
 */
function ModularTable(_ref) {
  let {
      data,
      columns,
      emptyMsg,
      footer,
      sortable,
      getHeaderProps,
      getRowProps,
      getCellProps,
      getRowId,
      initialSortColumn,
      initialSortDirection,
      autoResetSortBy = false,
      subhead
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded);
  const sortBy = (0, _react.useMemo)(() => initialSortColumn ? [{
    id: initialSortColumn,
    desc: initialSortDirection === "descending"
  }] : [], [initialSortColumn, initialSortDirection]);
  const {
    getTableProps,
    getTableBodyProps,
    headerGroups,
    rows,
    prepareRow
  } = (0, _reactTable.useTable)({
    columns,
    data,
    getRowId: getRowId || undefined,
    initialState: {
      sortBy
    },
    autoResetSortBy
  }, sortable ? _reactTable.useSortBy : undefined);
  const showEmpty = !!emptyMsg && (!rows || rows.length === 0);

  // Function returns whether table can be sorted by a specific column.
  // Returns true if sorting is enabled for the column and there is text
  // or JSX provided for the header, otherwise returns false.
  const isColumnSortable = column => column.canSort && ( /*#__PURE__*/(0, _react.isValidElement)(column.Header) || (typeof column.Header === "string" || typeof column.Header === "number") && !!String(column.Header).trim());
  const getColumnSortDirection = column => {
    if (!isColumnSortable(column)) {
      return undefined;
    }
    if (!column.isSorted) {
      return "none";
    }
    return column.isSortedDesc ? "descending" : "ascending";
  };
  return /*#__PURE__*/_react.default.createElement(_Table.default, _extends({}, getTableProps(), props), /*#__PURE__*/_react.default.createElement("thead", null, headerGroups.map((headerGroup, i) => /*#__PURE__*/_react.default.createElement(_TableRow.default, _extends({}, headerGroup.getHeaderGroupProps(), {
    key: i
  }), headerGroup.headers.map((column, j) => /*#__PURE__*/_react.default.createElement(_TableHeader.default, _extends({
    key: j,
    sort: getColumnSortDirection(column)
  }, column.getHeaderProps([{
    className: column.className
  }, {
    className: column.getCellIcon ? "p-table__cell--icon-placeholder" : ""
  }, _objectSpread({}, getHeaderProps === null || getHeaderProps === void 0 ? void 0 : getHeaderProps(column)),
  // Only call this if we want it to be sortable too.
  sortable && isColumnSortable(column) ? column.getSortByToggleProps({
    title: undefined
  }) : {}])), column.render("Header"))))), subhead), /*#__PURE__*/_react.default.createElement("tbody", getTableBodyProps(), generateRows(rows, prepareRow, getRowProps, getCellProps), showEmpty && /*#__PURE__*/_react.default.createElement(_TableRow.default, null, /*#__PURE__*/_react.default.createElement(_TableCell.default, {
    colSpan: columns.length
  }, emptyMsg)), footer && /*#__PURE__*/_react.default.createElement(_TableRow.default, null, /*#__PURE__*/_react.default.createElement(_TableCell.default, {
    colSpan: columns.length
  }, footer))));
}
var _default = exports.default = ModularTable;