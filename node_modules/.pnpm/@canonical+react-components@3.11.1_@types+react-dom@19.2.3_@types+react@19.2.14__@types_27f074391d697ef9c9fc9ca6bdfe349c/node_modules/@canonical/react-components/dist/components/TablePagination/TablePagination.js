"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
require("./TablePagination.scss");
var _TablePaginationControls = _interopRequireDefault(require("./TablePaginationControls"));
var _utils = require("./utils");
var _hooks = require("../../hooks");
const _excluded = ["data", "dataForwardProp", "itemName", "className", "description", "pageLimits", "position", "externallyControlled", "children"];
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
/**
This is an HOC [React](https://reactjs.org/) component for applying pagination to direct children components. This component is un-opinionated about
the structure of the input data and can be used with any child component that displays a list of data. However, the styling and behaviour of this component were designed
to work nicely with the `MainTable` component. To use this component, simply wrap a child component with it and provide the data that you want
to paginate to the `data` prop. This component will then pass the paged data to all <b>direct</b> child components via a child prop specified by `dataForwardProp`.
The component may be externally controlled, see following sections for detailed explanation.

#### Externally controlled pagination

For externally controlled mode, you will be responsible for the pagination logic and therefore the component will be purely presentational.
The pagination behaviour is controlled outside of this component. Note the data injection to child components is essentially a passthrough in this case.
To enable externally controlled mode for this component, set the `externallyControlled` prop to `true`. From there, it is your responsibility
to ensure that the following props `totalItems`, `currentPage`, `pageSize`, `onPageChange` and `onPageSizeChange` are set properly.
You can refer to the props table below on how to set these props.

#### Un-controlled pagination

In this mode, the component assumes that the input data is not paginated. The component will implement the pagination logic and apply it to the input data
then inject the paged data into direct child components. This is the default mode of operations for the component where `externallyControlled` prop is set
to `false`.
 */
const TablePagination = props => {
  const {
      data,
      dataForwardProp = "rows",
      itemName = "item",
      className,
      description,
      pageLimits = _utils.DEFAULT_PAGE_LIMITS,
      position = "above",
      externallyControlled,
      children
    } = props,
    divProps = _objectWithoutProperties(props, _excluded);

  // Safety check to ensure pageSize is a valid option in
  // pageLimits if the component is externally controlled
  if (externallyControlled) {
    let pageSizeFound = false;
    for (const limit of pageLimits) {
      if (limit === Number(props.pageSize)) {
        pageSizeFound = true;
        break;
      }
    }
    if (!pageSizeFound) {
      throw new Error("pageSize must be a valid option in pageLimits, pageLimits is set to [".concat(pageLimits, "]"));
    }
  }
  const [internalPageSize, setInternalPageSize] = (0, _react.useState)(() => {
    return (0, _utils.generatePagingOptions)(pageLimits)[0].value;
  });
  const {
    paginate,
    currentPage: internalCurrentPage,
    pageData: internalData
  } = (0, _hooks.usePagination)(externallyControlled ? [] : data, {
    itemsPerPage: internalPageSize,
    autoResetPage: true
  });
  const controlData = externallyControlled ? data : internalData;
  const controlPageSize = externallyControlled ? props.pageSize : internalPageSize;
  const controlTotalItems = externallyControlled ? props.totalItems : data.length;
  const controlCurrentPage = externallyControlled ? props.currentPage : internalCurrentPage;
  const handlePageChange = page => {
    if (externallyControlled) {
      props.onPageChange(page);
      return;
    }
    paginate(page);
  };
  const handlePageSizeChange = pageSize => {
    if (externallyControlled) {
      props.onPageSizeChange(pageSize);
      return;
    }
    paginate(1);
    setInternalPageSize(pageSize);
  };
  const clonedChildren = (0, _utils.renderChildren)(children, dataForwardProp, controlData);
  const controls = /*#__PURE__*/_react.default.createElement(_TablePaginationControls.default, _extends({}, divProps, {
    visibleCount: controlData.length,
    className: className,
    itemName: itemName,
    description: description,
    pageLimits: pageLimits,
    totalItems: controlTotalItems,
    currentPage: controlCurrentPage,
    pageSize: controlPageSize,
    onPageChange: handlePageChange,
    onPageSizeChange: handlePageSizeChange
  }));
  return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, position === "above" && controls, clonedChildren, position === "below" && controls);
};
var _default = exports.default = TablePagination;