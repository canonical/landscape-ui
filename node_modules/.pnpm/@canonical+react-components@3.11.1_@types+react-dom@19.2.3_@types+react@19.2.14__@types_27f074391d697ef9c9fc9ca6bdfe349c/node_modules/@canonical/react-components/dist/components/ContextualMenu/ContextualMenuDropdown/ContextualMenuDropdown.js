"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNearestParentsZIndex = exports.default = exports.adjustForWindow = exports.Label = void 0;
var _classnames = _interopRequireDefault(require("classnames"));
var _react = _interopRequireWildcard(require("react"));
var _hooks = require("../../../hooks");
var _Button = _interopRequireDefault(require("../../Button"));
const _excluded = ["children", "className", "onClick"],
  _excluded2 = ["adjustedPosition", "autoAdjust", "handleClose", "constrainPanelWidth", "dropdownClassName", "dropdownContent", "id", "isOpen", "links", "position", "positionCoords", "positionNode", "scrollOverflow", "setAdjustedPosition", "contextualMenuClassName"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
let Label = exports.Label = /*#__PURE__*/function (Label) {
  Label["Dropdown"] = "submenu";
  return Label;
}({});
/**
 * The type of the menu links.
 * @template L - The type of the link props.
 */
/**
 * The props for the ContextualMenuDropdown component.
 * @template L - The type of the link props.
 */
/**
 * Calculate the styles for the menu.
 * @param position - The menu position.
 * @param positionCoords - The coordinates of the position node.
 * @param constrainPanelWidth - Whether the menu width should be constrained to the position width.
 */
const getPositionStyle = (position, verticalPosition, positionCoords, constrainPanelWidth) => {
  if (!positionCoords) {
    return null;
  }
  const {
    height,
    left,
    top,
    width
  } = positionCoords;
  const topPos = verticalPosition === "bottom" ? top + height + (window.scrollY || 0) : top + (window.scrollY || 0);
  let leftPos = left;
  switch (position) {
    case "left":
      leftPos = left;
      break;
    case "center":
      leftPos = left + width / 2;
      break;
    case "right":
      leftPos = left + width;
      break;
    default:
      break;
  }
  return _objectSpread({
    position: "absolute",
    left: leftPos,
    top: topPos
  }, constrainPanelWidth ? {
    width
  } : null);
};

/**
 * Calculate the adjusted position in relation to the window.
 * @param position - The requested position.
 * @param fitsWindow - The window fitment info.
 * @return The new position.
 */
const adjustForWindow = (position, fitsWindow) => {
  let newPosition = position;
  if (!fitsWindow.fromRight.fitsLeft && newPosition === "right") {
    newPosition = "left";
  }
  if (!fitsWindow.fromLeft.fitsRight && newPosition === "left") {
    newPosition = "right";
  }
  // If the menu doesn't fit to the left or the right then center it.
  if (!fitsWindow.fromLeft.fitsRight && !fitsWindow.fromRight.fitsLeft && (newPosition === "left" || newPosition === "right")) {
    newPosition = "center";
  }
  // If the menu doesn't fit when centered then find a new position.
  if (newPosition === "center" && (!fitsWindow.fromCenter.fitsCentered.fitsRight || !fitsWindow.fromCenter.fitsCentered.fitsLeft)) {
    if (fitsWindow.fromLeft.fitsRight) {
      newPosition = "left";
    }
    if (fitsWindow.fromRight.fitsLeft) {
      newPosition = "right";
    }
  }
  return newPosition;
};

/**
 * Generate a menu link
 * @template L - The type of the link props.
 * @param link - A button
 * @param key - A key for the DOM.
 * @param handleClose - The function to close the menu.
 */
exports.adjustForWindow = adjustForWindow;
const generateLink = (link, key, handleClose) => {
  const {
      children,
      className,
      onClick
    } = link,
    props = _objectWithoutProperties(link, _excluded);
  return /*#__PURE__*/_react.default.createElement(_Button.default, _extends({
    className: (0, _classnames.default)("p-contextual-menu__link", className),
    key: key,
    onClick: onClick ? evt => {
      handleClose(evt.nativeEvent);
      onClick(evt);
    } : null
  }, props), children);
};
const getClosestScrollableParent = node => {
  let currentNode = node;
  while (currentNode && currentNode !== document.body) {
    const {
      overflowY,
      overflowX
    } = window.getComputedStyle(currentNode);
    if (["auto", "scroll", "overlay"].includes(overflowY) && ["auto", "scroll", "overlay"].includes(overflowX)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }
  return document.body;
};

// nearest parents z-index that is not 0 or auto
const getNearestParentsZIndex = element => {
  if (!window || !element) {
    return "0";
  }
  const zIndex = window.getComputedStyle(element, null).getPropertyValue("z-index");
  if (!element.parentElement) {
    return zIndex;
  }
  if (zIndex === "auto" || zIndex === "0" || zIndex === "") {
    return getNearestParentsZIndex(element.parentElement);
  }
  return zIndex;
};
exports.getNearestParentsZIndex = getNearestParentsZIndex;
const ContextualMenuDropdown = _ref => {
  let {
      adjustedPosition,
      autoAdjust,
      handleClose,
      constrainPanelWidth,
      dropdownClassName,
      dropdownContent,
      id,
      isOpen,
      links,
      position,
      positionCoords,
      positionNode,
      scrollOverflow,
      setAdjustedPosition,
      contextualMenuClassName
    } = _ref,
    props = _objectWithoutProperties(_ref, _excluded2);
  const dropdown = (0, _react.useRef)(null);
  const [verticalPosition, setVerticalPosition] = (0, _react.useState)("bottom");
  const [positionStyle, setPositionStyle] = (0, _react.useState)(getPositionStyle(adjustedPosition, verticalPosition, positionCoords, constrainPanelWidth));
  const [maxHeight, setMaxHeight] = (0, _react.useState)();
  // Update the styles to position the menu.
  const updatePositionStyle = (0, _react.useCallback)(() => {
    setPositionStyle(getPositionStyle(adjustedPosition, verticalPosition, positionCoords, constrainPanelWidth));
  }, [adjustedPosition, positionCoords, verticalPosition, constrainPanelWidth]);
  const updateVerticalPosition = (0, _react.useCallback)(() => {
    var _dropdown$current$get;
    if (!positionNode) {
      return;
    }
    const scrollableParent = getClosestScrollableParent(positionNode);
    if (!scrollableParent) {
      return;
    }
    const scrollableParentRect = scrollableParent.getBoundingClientRect();
    const toggleRect = positionNode.getBoundingClientRect();

    // Calculate the rect in relation to the scrollableParent
    const relativeToScrollParentRect = {
      top: toggleRect.top - scrollableParentRect.top,
      bottom: toggleRect.bottom - scrollableParentRect.top
    };
    const scrollParentSpaceBelow = scrollableParentRect.height - relativeToScrollParentRect.bottom;
    const scrollParentSpaceAbove = relativeToScrollParentRect.top;
    const dropdownHeight = (_dropdown$current$get = dropdown.current.getBoundingClientRect().height) !== null && _dropdown$current$get !== void 0 ? _dropdown$current$get : 0;
    const windowSpaceBelow = window.innerHeight - toggleRect.bottom;
    setVerticalPosition(scrollParentSpaceBelow >= dropdownHeight && windowSpaceBelow >= dropdownHeight || windowSpaceBelow > scrollParentSpaceAbove ? "bottom" : "top");
  }, [positionNode]);

  // Update the position when the window fitment info changes.
  const onUpdateWindowFitment = (0, _react.useCallback)(fitsWindow => {
    if (autoAdjust) {
      setAdjustedPosition(adjustForWindow(position, fitsWindow));
      updateVerticalPosition();
    }
    if (scrollOverflow) {
      setMaxHeight(fitsWindow.fromBottom.spaceBelow - 16);
    }
  }, [autoAdjust, position, scrollOverflow, setAdjustedPosition, updateVerticalPosition]);

  // Handle adjusting the horizontal position and scrolling of the dropdown so that it remains on screen.
  (0, _hooks.useWindowFitment)(dropdown.current, positionNode, onUpdateWindowFitment, 0, isOpen && (autoAdjust || scrollOverflow));

  // Update the styles when the position changes.
  (0, _react.useEffect)(() => {
    updatePositionStyle();
  }, [adjustedPosition, updatePositionStyle]);
  (0, _react.useEffect)(() => {
    updateVerticalPosition();
  }, [updateVerticalPosition]);
  (0, _react.useEffect)(() => {
    if (!dropdown.current) return;

    // align z-index: when we are in a modal context, we want the dropdown to be above the modal
    // apply the nearest parents z-index + 1
    const zIndex = getNearestParentsZIndex(positionNode);
    if (parseInt(zIndex) > 0) {
      var _dropdown$current$par;
      (_dropdown$current$par = dropdown.current.parentElement) === null || _dropdown$current$par === void 0 || _dropdown$current$par.style.setProperty("z-index", zIndex + 1);
    }
  }, [positionNode]);
  return (
    /*#__PURE__*/
    // Vanilla Framework uses .p-contextual-menu parent modifier classnames to determine the correct position of the .p-contextual-menu__dropdown dropdown (left, center, right).
    // Extra span wrapper is required as the dropdown is rendered in a portal.
    _react.default.createElement("span", {
      className: contextualMenuClassName,
      style: positionStyle
    }, /*#__PURE__*/_react.default.createElement("span", _extends({
      className: (0, _classnames.default)("p-contextual-menu__dropdown", dropdownClassName),
      id: id,
      "aria-hidden": isOpen ? "false" : "true",
      "aria-label": Label.Dropdown,
      ref: dropdown,
      style: _objectSpread(_objectSpread(_objectSpread({}, constrainPanelWidth && positionStyle !== null && positionStyle !== void 0 && positionStyle.width ? {
        width: positionStyle.width,
        minWidth: 0,
        maxWidth: "none"
      } : {}), scrollOverflow ? {
        maxHeight,
        minHeight: "2rem",
        overflowX: "auto"
      } : {}), verticalPosition === "top" ? {
        bottom: "0"
      } : {})
    }, props), dropdownContent ? typeof dropdownContent === "function" ? dropdownContent(handleClose) : dropdownContent : links.map((item, i) => {
      if (Array.isArray(item)) {
        return /*#__PURE__*/_react.default.createElement("span", {
          className: "p-contextual-menu__group",
          key: i
        }, item.map((link, j) => generateLink(link, j, handleClose)));
      } else if (typeof item === "string") {
        return /*#__PURE__*/_react.default.createElement("div", {
          className: "p-contextual-menu__non-interactive",
          key: i
        }, item);
      }
      return generateLink(item, i, handleClose);
    })))
  );
};
var _default = exports.default = ContextualMenuDropdown;