import { useEffect, useRef } from "react";
import { useThrottle } from "./useThrottle";
import { usePrevious } from "./usePrevious";

/**
 * A hook that handles attaching/removing listeners and smartly reattaching if
 * any of the attributes change.
 * @param targetNode The node to attach the listener to.
 * @param callback The function to call from the listener.
 * @param eventType The event name.
 * @param shouldThrottle Whether the callback calls should be throttled.
 * @param shouldListen When the listener should be active.
 * @param options Native event listener options.
 */
export var useListener = function useListener(targetNode, callback, eventType) {
  var shouldThrottle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var shouldListen = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
  var options = arguments.length > 5 ? arguments[5] : undefined;
  var isListening = useRef(false);
  var throttle = useThrottle(callback);
  var eventListener = useRef(shouldThrottle ? throttle : callback);
  var previousEventType = usePrevious(eventType);
  var previousShouldThrottle = usePrevious(shouldThrottle);
  var previousTargetNode = usePrevious(targetNode);
  var previousCallback = usePrevious(callback);
  var previousOptions = usePrevious(options);
  useEffect(() => {
    // If any of the props related to the attached listener changed then the
    // listener needs to be re-attached.
    var listenerAttributesChanged = callback !== previousCallback || eventType !== previousEventType || shouldThrottle !== previousShouldThrottle || targetNode !== previousTargetNode || options !== previousOptions;
    if (isListening.current && (!shouldListen || listenerAttributesChanged)) {
      previousTargetNode.removeEventListener(previousEventType, eventListener.current, previousOptions);
      isListening.current = false;
    }
    if (shouldThrottle !== previousShouldThrottle || callback !== previousCallback) {
      // Set the listener to the callback, or used the throttled callback.
      eventListener.current = shouldThrottle ? throttle : callback;
    }
    if (targetNode && shouldListen && !isListening.current) {
      targetNode.addEventListener(eventType, eventListener.current, options);
      isListening.current = true;
    }
    return () => {
      // Unattach the listener if the component gets unmounted while
      // listening.
      if (targetNode && eventListener.current && isListening.current) {
        targetNode.removeEventListener(eventType, eventListener.current, options);
        isListening.current = false;
      }
    };
  }, [callback, eventType, options, previousCallback, previousEventType, previousOptions, previousShouldThrottle, previousTargetNode, shouldListen, shouldThrottle, targetNode, throttle]);
};