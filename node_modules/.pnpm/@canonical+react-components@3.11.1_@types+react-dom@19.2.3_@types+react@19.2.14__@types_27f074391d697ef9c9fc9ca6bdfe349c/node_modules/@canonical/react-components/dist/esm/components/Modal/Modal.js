var _excluded = ["buttonRow", "children", "className", "close", "focusRef", "title", "shouldPropagateClickEvent", "closeOnOutsideClick"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import classNames from "classnames";
import React, { useId, useRef, useEffect } from "react";
/**
 * This is a [React](https://reactjs.org/) component for the Vanilla [Modal](https://docs.vanillaframework.io/patterns/modal/).
 *
 * The modal component can be used to overlay an area of the screen which can contain a prompt, dialog or interaction.
 */
export var Modal = _ref => {
  var {
      buttonRow,
      children,
      className,
      close,
      focusRef,
      title,
      shouldPropagateClickEvent = false,
      closeOnOutsideClick = true
    } = _ref,
    wrapperProps = _objectWithoutProperties(_ref, _excluded);
  // list of focusable selectors is based on this Stack Overflow answer:
  // https://stackoverflow.com/a/30753870/3732840
  var focusableElementSelectors = 'a[href]:not([tabindex="-1"]), button:not([disabled]), textarea:not([disabled]):not([tabindex="-1"]), input:not([disabled]):not([tabindex="-1"]), select:not([disabled]):not([tabindex="-1"]), area[href]:not([tabindex="-1"]), iframe:not([tabindex="-1"]), [tabindex]:not([tabindex="-1"]), [contentEditable=true]:not([tabindex="-1"])';
  var descriptionId = useId();
  var titleId = useId();
  var shouldClose = useRef(false);
  var modalRef = useRef(null);
  var closeButtonRef = useRef(null);
  var handleTabKey = event => {
    var focusableModalElements = modalRef.current.querySelectorAll(focusableElementSelectors);
    if (focusableModalElements.length > 0) {
      var firstElement = focusableModalElements[0];
      var lastElement = focusableModalElements[focusableModalElements.length - 1];
      if (!event.shiftKey && document.activeElement === lastElement) {
        firstElement.focus();
        event.preventDefault();
      }
      if (event.shiftKey && document.activeElement === firstElement) {
        lastElement.focus();
        return event.preventDefault();
      }
    }
  };
  var handleEscKey = event => {
    if ("nativeEvent" in event && event.nativeEvent.stopImmediatePropagation) {
      event.nativeEvent.stopImmediatePropagation();
    } else if ("stopImmediatePropagation" in event) {
      event.stopImmediatePropagation();
    } else if (event.stopPropagation) {
      event.stopPropagation();
    }
    if (close) {
      close();
    }
  };
  useEffect(() => {
    if (focusRef !== null && focusRef !== void 0 && focusRef.current) {
      focusRef.current.focus();
    } else if (closeButtonRef.current) {
      closeButtonRef.current.focus();
    } else {
      modalRef.current.focus();
    }
  }, [focusRef]);
  useEffect(() => {
    var keyListenersMap = new Map([["Escape", handleEscKey], ["Tab", handleTabKey]]);
    var keyDown = event => {
      var listener = keyListenersMap.get(event.code);
      return listener && listener(event);
    };
    document.addEventListener("keydown", keyDown);
    return () => {
      document.removeEventListener("keydown", keyDown);
    };
  });
  var handleContentOnMouseDown = () => {
    shouldClose.current = false;
  };
  var handleContentOnMouseUp = () => {
    shouldClose.current = false;
  };
  var handleOverlayOnMouseDown = event => {
    if (event.target === modalRef.current && closeOnOutsideClick) {
      shouldClose.current = true;
    }
  };
  var handleClose = event => {
    if (!shouldPropagateClickEvent) {
      event.stopPropagation();
    }
    if (close) {
      close();
    }
  };
  var handleOverlayOnClick = event => {
    if (shouldClose.current) {
      handleClose(event);
    }
  };
  return /*#__PURE__*/React.createElement("div", _extends({
    className: classNames("p-modal", className),
    onClick: handleOverlayOnClick,
    onMouseDown: handleOverlayOnMouseDown
  }, wrapperProps, {
    ref: modalRef
  }), /*#__PURE__*/React.createElement("section", {
    className: "p-modal__dialog",
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": titleId,
    "aria-describedby": descriptionId,
    onMouseDown: handleContentOnMouseDown,
    onMouseUp: handleContentOnMouseUp
  }, !!title && /*#__PURE__*/React.createElement("header", {
    className: "p-modal__header"
  }, /*#__PURE__*/React.createElement("h2", {
    className: "p-modal__title",
    id: titleId
  }, title), close && /*#__PURE__*/React.createElement("button", {
    type: "button",
    className: "p-modal__close",
    "aria-label": "Close active modal",
    onClick: handleClose,
    ref: closeButtonRef
  }, "Close")), /*#__PURE__*/React.createElement("div", {
    id: descriptionId
  }, children), !!buttonRow && /*#__PURE__*/React.createElement("footer", {
    className: "p-modal__footer"
  }, buttonRow)));
};
export default Modal;