import _pt from "prop-types";
import Button from "../../Button";
import Icon from "../../Icon";
import Notification from "../Notification";
import { DefaultTitles } from "../Notification/Notification";
import { useLayoutEffect, useRef, useState, useEffect } from "react";
import { createPortal } from "react-dom";
import Animate from "./Animate";
import { usePrefersReducedMotion } from "../../../hooks";
import React from "react";
import { ICONS } from "../../Icon";
import "./Toast.scss";
export var severityOrder = ["positive", "caution", "negative", "information"];
export var iconLookup = {
  positive: ICONS.success,
  information: ICONS.information,
  caution: ICONS.warning,
  negative: ICONS.error
};
var ToastNotificationList = _ref => {
  var {
    notifications,
    onDismiss,
    groupedCount = {},
    show
  } = _ref;
  var [filters, setFilters] = useState(new Set());
  var prevNotificationsSize = useRef(notifications.length);
  var containerRef = useRef(null);
  var hasFilters = !!filters.size;
  var preferReducedMotion = usePrefersReducedMotion();
  useLayoutEffect(() => {
    adjustScrollPosition();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [notifications]);

  // this layout effect is used to maintain scroll position of the
  // notification list when new notifications are added to the list
  // for only when the scroll is at the top
  var adjustScrollPosition = () => {
    var notificationsRemoved = notifications.length < prevNotificationsSize.current;
    prevNotificationsSize.current = notifications.length;
    if (!notifications.length || notificationsRemoved) {
      return;
    }
    var container = containerRef.current;
    var lastNotification = notifications[notifications.length - 1];
    var notificationEl = document.getElementById(lastNotification.id);
    if (container && notificationEl) {
      var currentScrollY = container.scrollTop;
      var offsetHeight = notificationEl.getBoundingClientRect().height + parseFloat(window.getComputedStyle(notificationEl).marginTop) + parseFloat(window.getComputedStyle(notificationEl).marginBottom);
      // only adjust the scroll height if the scroll is at the top
      if (currentScrollY === 0) {
        container.scrollTop = currentScrollY + offsetHeight;
      }
    }
  };
  var handleFilterSelect = filter => {
    setFilters(prevFilters => {
      var newFilters = new Set(prevFilters);
      if (!newFilters.has(filter)) {
        newFilters.add(filter);
      } else {
        newFilters.delete(filter);
      }
      return newFilters;
    });
  };
  var handleGroupedDismiss = () => {
    if (hasFilters) {
      var notificationsToClear = notifications.filter(notification => filters.has(notification.type));
      onDismiss(notificationsToClear);
      setFilters(new Set());
      return;
    }
    onDismiss(notifications);
  };
  var getSeverityFilters = () => {
    var filterButtons = severityOrder.map(severity => {
      if (groupedCount[severity]) {
        return /*#__PURE__*/React.createElement("button", {
          "aria-label": "Filter ".concat(severity, " notifications"),
          "aria-pressed": filters.has(severity),
          key: severity,
          className: "u-no-margin u-no-border filter-button",
          onClick: () => {
            handleFilterSelect(severity);
          }
        }, /*#__PURE__*/React.createElement(Icon, {
          name: iconLookup[severity]
        }), /*#__PURE__*/React.createElement("span", null, groupedCount[severity]));
      }
      return null;
    });
    return /*#__PURE__*/React.createElement("div", {
      className: "filters"
    }, filterButtons, hasFilters && /*#__PURE__*/React.createElement("button", {
      className: "u-no-margin--bottom u-no-border",
      onClick: () => {
        setFilters(new Set());
      }
    }, "Clear filters"));
  };
  var getDismissText = () => {
    if (hasFilters) {
      var validFilters = Object.keys(groupedCount);
      var totalCount = 0;
      for (var filter of validFilters) {
        if (filters.has(filter)) {
          totalCount += groupedCount[filter] || 0;
        }
      }
      var dismissText = /*#__PURE__*/React.createElement("span", {
        className: "dismiss-text"
      }, "Dismiss ", totalCount);
      return dismissText;
    }
    return /*#__PURE__*/React.createElement("span", null, "Dismiss all");
  };
  var handleDismissNotification = notification => {
    if (preferReducedMotion) {
      onDismiss([notification]);
      return;
    }

    // animate the notification dismissal before updating states to delay unmounting
    var element = document.getElementById("li-".concat(notification.id));
    if (element) {
      element.style.transformOrigin = "center";
      element.style.overflow = "hidden";
      var animation = element.animate([{
        height: "".concat(element.scrollHeight, "px"),
        opacity: 1
      }, {
        height: "0px",
        opacity: 0
      }], {
        duration: 200,
        easing: "linear",
        fill: "forwards"
      });
      animation.onfinish = () => {
        element.style.display = "none";
        onDismiss([notification]);
      };
    }
  };

  // Only filter input data if there are filters present
  var filteredNotifications = hasFilters ? notifications.filter(notification => filters.has(notification.type)) : notifications;
  useEffect(() => {
    if (hasFilters && filteredNotifications.length === 0) {
      // if there are no filtered notifications, reset the filters
      setFilters(new Set());
    }
  }, [hasFilters, filteredNotifications]);

  // Don't assign alert role for notifications when expanded since we don't want
  // screen readers to announce every existing notification
  var notificationEls = filteredNotifications.map((_, index, array) => {
    var _notification$title;
    var lastNotificationIndex = array.length - 1;
    // This will map notifications in reverse order
    var notification = array[lastNotificationIndex - index];
    return /*#__PURE__*/React.createElement("li", {
      key: notification.id,
      id: "li-".concat(notification.id)
    }, /*#__PURE__*/React.createElement(Notification, {
      id: notification.id,
      title: (_notification$title = notification.title) !== null && _notification$title !== void 0 ? _notification$title : DefaultTitles[notification.type],
      actions: notification.actions,
      severity: notification.type,
      onDismiss: () => {
        handleDismissNotification(notification);
      },
      className: "u-no-margin--bottom individual-notification",
      timestamp: notification.timestamp,
      titleElement: "div"
    }, notification.message));
  });
  return /*#__PURE__*/createPortal( /*#__PURE__*/React.createElement(Animate, {
    show: show,
    from: {
      opacity: 0,
      transform: "translateY(5vh)"
    },
    to: {
      opacity: 1,
      transform: "translateY(0)"
    },
    options: {
      duration: 100
    },
    className: "toast-animate"
  }, /*#__PURE__*/React.createElement("ul", {
    className: "toast-notification-list",
    "aria-label": "Notifications list",
    ref: containerRef
  }, notificationEls, /*#__PURE__*/React.createElement("li", {
    className: "dismiss"
  }, getSeverityFilters(), /*#__PURE__*/React.createElement(Button, {
    className: "u-no-margin--bottom dismiss-button",
    onClick: handleGroupedDismiss,
    hasIcon: true
  }, /*#__PURE__*/React.createElement(Icon, {
    name: "tidy"
  }), getDismissText())))), document.body);
};
ToastNotificationList.propTypes = {
  notifications: _pt.array.isRequired,
  onDismiss: _pt.func.isRequired,
  show: _pt.bool.isRequired
};
export default ToastNotificationList;