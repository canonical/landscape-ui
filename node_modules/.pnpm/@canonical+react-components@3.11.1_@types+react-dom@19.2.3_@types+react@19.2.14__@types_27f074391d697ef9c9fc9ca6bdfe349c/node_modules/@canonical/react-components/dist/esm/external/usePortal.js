/**
 * This is a reference implementation of the usePortal hook from react-useportal: https://github.com/iamthesiz/react-useportal/blob/master/usePortal.ts
 * The license for the content in this file is goverened by the original project's license: https://github.com/iamthesiz/react-useportal/blob/master/license.md
 */
import { useState, useRef, useEffect, useCallback, useMemo } from "react";
import { createPortal } from "react-dom";
import { useSSR } from "./useSSR";
export var errorMessage1 = "You must either add a `ref` to the element you are interacting with or pass an `event` to openPortal(e) or togglePortal(e) when the `programmaticallyOpen` option is not set to `true`.";
export var usePortal = function usePortal() {
  var {
    closeOnOutsideClick = true,
    closeOnEsc = true,
    bindTo,
    // attach the portal to this node in the DOM
    isOpen: defaultIsOpen = false,
    onOpen,
    onClose,
    onPortalClick,
    programmaticallyOpen = false
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    isServer,
    isBrowser
  } = useSSR();
  var [isOpen, makeOpen] = useState(defaultIsOpen);
  // we use this ref because `isOpen` is stale for handleOutsideMouseClick
  var open = useRef(isOpen);
  var setOpen = useCallback(v => {
    // workaround to not have stale `isOpen` in the handleOutsideMouseClick
    open.current = v;
    makeOpen(v);
  }, []);
  var targetEl = useRef(null); // this is the element you are clicking/hovering/whatever, to trigger opening the portal
  var portal = useRef(isBrowser ? document.createElement("div") : null);
  useEffect(() => {
    if (isBrowser && !portal.current) portal.current = document.createElement("div");
  }, [isBrowser, portal]);
  var elToMountTo = useMemo(() => {
    if (isServer) return null;
    return bindTo && bindTo.current || document.body;
  }, [isServer, bindTo]);
  var createCustomEvent = e => {
    if (!e) return {
      portal,
      targetEl,
      event: e
    };
    var event = e || {};
    if (event.persist) event.persist();
    event.portal = portal;
    event.targetEl = targetEl;
    event.event = e;
    var {
      currentTarget
    } = e;
    if (!targetEl.current && currentTarget && currentTarget !== document) targetEl.current = event.currentTarget;
    return event;
  };
  var openPortal = useCallback(e => {
    if (isServer) return;
    var customEvent = createCustomEvent(e);
    // for some reason, when we don't have the event argument, there
    // is a weird race condition. Would like to see if we can remove
    // setTimeout, but for now this works
    if (targetEl.current == null && !programmaticallyOpen) {
      setTimeout(() => setOpen(true), 0);
      throw Error(errorMessage1);
    }
    if (onOpen) onOpen(customEvent);
    setOpen(true);
  }, [isServer, portal, setOpen, targetEl, onOpen, programmaticallyOpen]);
  var closePortal = useCallback(e => {
    if (isServer) return;
    var customEvent = createCustomEvent(e);
    if (onClose && open.current) onClose(customEvent);
    if (open.current) setOpen(false);
  }, [isServer, onClose, setOpen]);
  var togglePortal = useCallback(e => open.current ? closePortal(e) : openPortal(e), [closePortal, openPortal]);
  var handleKeydown = useCallback(e => e.key === "Escape" && closeOnEsc ? closePortal(e) : undefined, [closeOnEsc, closePortal]);
  var handleOutsideMouseClick = useCallback(e => {
    var containsTarget = target => target.current.contains(e.target);
    // There might not be a targetEl if the portal was opened programmatically.
    if (containsTarget(portal) || e.button !== 0 || !open.current || targetEl.current && containsTarget(targetEl)) return;
    if (closeOnOutsideClick) closePortal(e);
  }, [isServer, closePortal, closeOnOutsideClick, portal]);
  var handleMouseDown = useCallback(e => {
    if (isServer || !(portal.current instanceof HTMLElement)) return;
    var customEvent = createCustomEvent(e);
    if (portal.current.contains(customEvent.target) && onPortalClick) onPortalClick(customEvent);
    handleOutsideMouseClick(e);
  }, [handleOutsideMouseClick, isServer]);
  useEffect(() => {
    if (isServer) return null;
    if (!(elToMountTo instanceof HTMLElement) || !(portal.current instanceof HTMLElement)) return null;
    var node = portal.current;
    elToMountTo.appendChild(portal.current);
    document.addEventListener("keydown", handleKeydown);
    document.addEventListener("mousedown", handleMouseDown);
    return () => {
      document.removeEventListener("keydown", handleKeydown);
      document.removeEventListener("mousedown", handleMouseDown);
      elToMountTo.removeChild(node);
    };
  }, [isServer, handleOutsideMouseClick, handleKeydown, elToMountTo, portal]);
  var Portal = useCallback(_ref => {
    var {
      children
    } = _ref;
    if (portal.current != null) return /*#__PURE__*/createPortal(children, portal.current);
    return null;
  }, [portal]);
  return Object.assign([openPortal, closePortal, open.current, Portal, togglePortal, targetEl, portal], {
    isOpen: open.current,
    openPortal,
    ref: targetEl,
    closePortal,
    togglePortal,
    Portal,
    portalRef: portal,
    bind: {
      // used if you want to spread all html attributes onto the target element
      ref: targetEl
    }
  });
};