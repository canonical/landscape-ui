/**
 * Checks if a given IP address is a valid IPv4 address.
 * @param ip The IP address to check
 * @returns True if the IP is a valid IPv4 address, false otherwise
 */
export var isIPv4 = ip => {
  var ipv4Regex = /^(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}$/;
  return ipv4Regex.test(ip);
};

/**
 * Takes a subnet CIDR notation (IPv4) and returns the first and last IP of the subnet.
 * The network and host addresses are excluded.
 *
 * @param cidr The CIDR notation of the subnet
 * @returns The first and last valid IP addresses as two strings in a list.
 */
export var getIpRangeFromCidr = cidr => {
  // https://gist.github.com/binarymax/6114792

  // Get start IP and number of valid addresses
  var [startIp, mask] = cidr.split("/");
  var numberOfAddresses = (1 << 32 - parseInt(mask)) - 1;

  // IPv4 can be represented by an unsigned 32-bit integer, so we can use a Uint32Array to store the IP
  var buffer = new ArrayBuffer(4); //4 octets
  var int32 = new Uint32Array(buffer);

  // Convert starting IP to Uint32 and add the number of addresses to get the end IP.
  // Subtract 1 from the number of addresses to exclude the broadcast address.
  int32[0] = convertIpToUint32(startIp) + numberOfAddresses - 1;

  // Convert the buffer to a Uint8Array to get the octets, then convert it to an array
  var arrayApplyBuffer = Array.from(new Uint8Array(buffer));

  // Reverse the octets and join them with "." to get the end IP
  var endIp = arrayApplyBuffer.reverse().join(".");
  var firstValidIp = getFirstValidIp(startIp);
  return [firstValidIp, endIp];
};
export var getFirstValidIp = ip => {
  var buffer = new ArrayBuffer(4); //4 octets
  var int32 = new Uint32Array(buffer);

  // add 1 because the first IP is the network address
  int32[0] = convertIpToUint32(ip) + 1;
  var arrayApplyBuffer = Array.from(new Uint8Array(buffer));
  return arrayApplyBuffer.reverse().join(".");
};
export var convertIpToUint32 = ip => {
  var octets = ip.split(".").map(a => parseInt(a));
  var buffer = new ArrayBuffer(4);
  var int32 = new Uint32Array(buffer);
  int32[0] = (octets[0] << 24) + (octets[1] << 16) + (octets[2] << 8) + octets[3];
  return int32[0];
};

/**
 * Checks if an IPv4 address is valid for the given subnet.
 *
 * @param ip The IPv4 address to check, as a string
 * @param cidr The subnet's CIDR notation e.g. 192.168.0.0/24
 * @returns True if the IP is in the subnet, false otherwise
 */
export var isIpInSubnet = (ip, cidr) => {
  var [startIP, endIP] = getIpRangeFromCidr(cidr);
  var ipUint32 = convertIpToUint32(ip);
  var startIPUint32 = convertIpToUint32(startIP);
  var endIPUint32 = convertIpToUint32(endIP);
  return ipUint32 >= startIPUint32 && ipUint32 <= endIPUint32;
};

/**
 * Separates the immutable and editable octets of an IPv4 subnet range.
 *
 * @param startIp The start IP of the subnet
 * @param endIp The end IP of the subnet
 * @returns The immutable and editable octects as two strings in a list
 */
export var getImmutableAndEditableOctets = (startIp, endIp) => {
  var startIpOctetList = startIp.split(".");
  var endIpOctetList = endIp.split(".");
  var immutable = [];
  var editable = [];
  startIpOctetList.forEach((octet, index) => {
    if (octet === endIpOctetList[index]) {
      immutable.push(octet);
    } else {
      editable.push("[".concat(octet, "-").concat(endIpOctetList[index], "]"));
    }
  });
  return [immutable.join("."), editable.join(".")];
};

/**
 * Get the immutable and editable parts of an IPv4 or IPv6 subnet.
 *
 * @param cidr The CIDR notation of the subnet
 * @returns The immutable and editable  as two strings in a list
 */
export var getImmutableAndEditable = cidr => {
  var isIPV4 = isIPv4(cidr.split("/")[0]);
  if (isIPV4) {
    var [startIp, endIp] = getIpRangeFromCidr(cidr);
    return getImmutableAndEditableOctets(startIp, endIp);
  }
  var [networkAddress] = cidr.split("/");
  var immutableIPV6 = networkAddress.substring(0, networkAddress.lastIndexOf(":"));
  var ipv6PlaceholderColons = 7 - (immutableIPV6.match(/:/g) || []).length; // 7 is the maximum number of colons in an IPv6 address
  var editableIPV6 = "".concat("0000:".repeat(ipv6PlaceholderColons), "0000");
  return [immutableIPV6, editableIPV6];
};