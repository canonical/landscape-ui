import _pt from "prop-types";
var _excluded = ["items", "selectedItems", "disabledItems", "header", "updateItems", "onSelectItem", "onDeselectItem", "isOpen", "footer", "sortFn", "groupFn", "hasSelectedItemsFirst"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import classNames from "classnames";
import React, { useEffect, useId, useMemo, useRef, useState } from "react";
import "./MultiSelect.scss";
import { Button, CheckboxInput, ContextualMenu, SearchBox } from "../../index";
import { FadeInDown } from "./FadeInDown";
var sortAlphabetically = (a, b) => {
  return a.label.localeCompare(b.label, "en", {
    numeric: true
  });
};
var createSortSelectedItems = previouslySelectedItemValues => (a, b) => {
  if (previouslySelectedItemValues) {
    var aIsPreviouslySelected = previouslySelectedItemValues.has(a.value);
    var bIsPreviouslySelected = previouslySelectedItemValues.has(b.value);
    if (aIsPreviouslySelected && !bIsPreviouslySelected) return -1;
    if (!aIsPreviouslySelected && bIsPreviouslySelected) return 1;
  }
  return 0;
};
var getGroupedItems = items => {
  var groups = new Map();
  items.forEach(item => {
    var group = item.group || "Ungrouped";
    var groupItems = groups.get(group) || [];
    groupItems.push(item);
    groups.set(group, groupItems);
  });
  return Array.from(groups, _ref => {
    var [group, items] = _ref;
    return {
      group,
      items
    };
  });
};
export var MultiSelectDropdown = _ref2 => {
  var {
      items,
      selectedItems,
      disabledItems,
      header,
      updateItems,
      onSelectItem,
      onDeselectItem,
      isOpen,
      footer,
      sortFn = sortAlphabetically,
      groupFn = getGroupedItems,
      hasSelectedItemsFirst = true
    } = _ref2,
    props = _objectWithoutProperties(_ref2, _excluded);
  var selectedItemValues = useMemo(() => new Set(selectedItems.map(item => item.value)), [selectedItems]);
  var disabledItemValues = useMemo(() => new Set(disabledItems.map(item => item.value)), [disabledItems]);
  var [previouslySelectedItemValues, setPreviouslySelectedItemValues] = useState(new Set(selectedItemValues));
  useEffect(() => {
    if (isOpen) {
      setPreviouslySelectedItemValues(new Set(selectedItemValues));
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isOpen]);
  var hasGroup = useMemo(() => items.some(item => item.group), [items]);
  var groupedItems = useMemo(() => hasGroup ? groupFn(items) : [{
    group: "Ungrouped",
    items
  }],
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [items, groupFn]);
  var handleOnChange = event => {
    var {
      checked,
      value
    } = event.target;
    var foundItem = items.find(item => "".concat(item.value) === value);
    if (foundItem) {
      var _selectedItems$filter;
      var newSelectedItems = checked ? [...selectedItems, foundItem] : (_selectedItems$filter = selectedItems.filter(item => "".concat(item.value) !== value)) !== null && _selectedItems$filter !== void 0 ? _selectedItems$filter : [];
      updateItems(newSelectedItems);
      if (checked) {
        onSelectItem === null || onSelectItem === void 0 || onSelectItem(foundItem);
      } else {
        onDeselectItem === null || onDeselectItem === void 0 || onDeselectItem(foundItem);
      }
    }
  };
  return /*#__PURE__*/React.createElement(FadeInDown, {
    isVisible: isOpen
  }, /*#__PURE__*/React.createElement("div", _extends({
    className: "multi-select__dropdown",
    role: "listbox"
  }, props), header ? header : null, groupedItems.map(_ref3 => {
    var {
      group,
      items
    } = _ref3;
    return /*#__PURE__*/React.createElement("div", {
      className: "multi-select__group",
      key: group
    }, hasGroup ? /*#__PURE__*/React.createElement("h5", {
      className: "multi-select__dropdown-header"
    }, group) : null, /*#__PURE__*/React.createElement("ul", {
      className: "multi-select__dropdown-list",
      "aria-label": group
    }, items.toSorted(sortFn).toSorted(hasSelectedItemsFirst ? createSortSelectedItems(previouslySelectedItemValues) : () => 0).map(item => /*#__PURE__*/React.createElement("li", {
      key: item.value,
      className: "multi-select__dropdown-item"
    }, /*#__PURE__*/React.createElement(CheckboxInput, {
      disabled: disabledItemValues.has(item.value),
      label: item.label,
      checked: selectedItemValues.has(item.value),
      value: item.value,
      onChange: handleOnChange,
      key: item.value
    })))));
  }), footer ? /*#__PURE__*/React.createElement("div", {
    className: "multi-select__footer"
  }, footer) : null));
};

/**
 * Component allowing to select multiple items from a list of options.
 *
 * `MultiSelectDropdown` displays the dropdown with options which are grouped and sorted alphabetically.
 * `SearchBox` or `Button` is used to trigger the dropdown depending on the variant.
 */
MultiSelectDropdown.propTypes = {
  isOpen: _pt.bool.isRequired,
  items: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })).isRequired,
  selectedItems: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })).isRequired,
  disabledItems: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })).isRequired,
  header: _pt.node,
  updateItems: _pt.func.isRequired,
  onDeselectItem: _pt.func,
  onSelectItem: _pt.func,
  footer: _pt.node,
  groupFn: _pt.func,
  sortFn: _pt.any,
  hasSelectedItemsFirst: _pt.bool
};
export var MultiSelect = _ref4 => {
  var {
    disabled,
    selectedItems: externalSelectedItems = [],
    label,
    listSelected = true,
    onItemsUpdate,
    onSelectItem,
    onDeselectItem,
    placeholder,
    required = false,
    items = [],
    disabledItems = [],
    dropdownHeader,
    dropdownFooter,
    showDropdownFooter = true,
    variant = "search",
    scrollOverflow = false,
    isSortedAlphabetically = true,
    hasSelectedItemsFirst = true,
    id,
    help,
    helpClassName
  } = _ref4;
  var buttonRef = useRef(null);
  var [isDropdownOpen, setIsDropdownOpen] = useState(false);
  var [filter, setFilter] = useState("");
  var [internalSelectedItems, setInternalSelectedItems] = useState([]);
  var selectedItems = externalSelectedItems || internalSelectedItems;
  var helpId = useId();
  var updateItems = newItems => {
    var uniqueItems = Array.from(new Set(newItems));
    setInternalSelectedItems(uniqueItems);
    onItemsUpdate && onItemsUpdate(uniqueItems);
  };
  var dropdownId = useId();
  var inputId = useId();
  var selectedItemsLabel = selectedItems.filter(selectedItem => items.some(item => item.value === selectedItem.value)).map(el => el.label).join(", ");
  var footer = null;
  if (showDropdownFooter) {
    footer = dropdownFooter ? dropdownFooter : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Button, {
      appearance: "link",
      onClick: () => {
        var enabledItems = items.filter(item => !disabledItems.some(disabledItem => disabledItem.value === item.value));
        updateItems([...selectedItems, ...enabledItems]);
      },
      type: "button"
    }, "Select all"), /*#__PURE__*/React.createElement(Button, {
      appearance: "link",
      onClick: () => {
        var disabledSelectedItems = selectedItems.filter(item => disabledItems.some(disabledItem => disabledItem.value === item.value));
        updateItems(disabledSelectedItems);
      },
      type: "button"
    }, "Clear"));
  }
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ContextualMenu, {
    className: "multi-select",
    onToggleMenu: isOpen => {
      if (!isOpen) {
        setFilter("");
      }
      // Handle syncing the state when toggling the menu from within the
      // contextual menu component e.g. when clicking outside.
      if (isOpen !== isDropdownOpen) {
        setIsDropdownOpen(isOpen);
      }
    },
    position: "left",
    constrainPanelWidth: true,
    toggle: variant === "search" ? /*#__PURE__*/React.createElement(SearchBox, {
      externallyControlled: true,
      "aria-controls": dropdownId,
      "aria-expanded": isDropdownOpen,
      id: id !== null && id !== void 0 ? id : inputId,
      role: "combobox",
      "aria-label": label || placeholder || "Search",
      disabled: disabled,
      autoComplete: "off",
      onChange: value => {
        setFilter(value);
        // reopen if dropdown has been closed via ESC
        setIsDropdownOpen(true);
      },
      onFocus: () => setIsDropdownOpen(true),
      placeholder: placeholder !== null && placeholder !== void 0 ? placeholder : "Search",
      required: required,
      type: "text",
      value: filter,
      className: "multi-select__input"
    }) : /*#__PURE__*/React.createElement("button", {
      role: "combobox",
      type: "button",
      "aria-label": label || placeholder || "Select items",
      "aria-controls": dropdownId,
      "aria-expanded": isDropdownOpen,
      className: "multi-select__select-button",
      onClick: () => {
        setIsDropdownOpen(!isDropdownOpen);
      },
      onMouseDown: event => {
        // If the dropdown is open when this button is clicked the
        // click-outside event will fire which will close the dropdown, but
        // then the button click event will fire which will immediately
        // reopen the dropdown.
        // To prevent this we can stop the propagation to the click event
        // while `isDropdownOpen` is still set to `true` (by the time we
        // get to the `onClick` event `isDropdownOpen` will already be `false`,
        // hence having to do this on mouse down).
        if (isDropdownOpen) {
          event.stopPropagation();
        }
      },
      ref: buttonRef,
      id: id,
      disabled: disabled
    }, /*#__PURE__*/React.createElement("span", {
      className: "multi-select__condensed-text"
    }, listSelected && selectedItems.length > 0 ? selectedItemsLabel : placeholder !== null && placeholder !== void 0 ? placeholder : "Select items")),
    visible: isDropdownOpen,
    scrollOverflow: scrollOverflow,
    "aria-describedby": help ? helpId : undefined
  }, /*#__PURE__*/React.createElement(MultiSelectDropdown, {
    id: dropdownId,
    isOpen: isDropdownOpen,
    items: filter.length > 0 ? items.filter(item => item.label.toLowerCase().includes(filter.toLowerCase())) : items,
    selectedItems: selectedItems,
    disabledItems: disabledItems,
    header: dropdownHeader,
    updateItems: updateItems,
    onSelectItem: onSelectItem,
    onDeselectItem: onDeselectItem,
    footer: footer,
    sortFn: isSortedAlphabetically ? sortAlphabetically : () => 0,
    hasSelectedItemsFirst: hasSelectedItemsFirst
  })), help && /*#__PURE__*/React.createElement("p", {
    className: classNames("p-form-help-text", helpClassName),
    id: helpId
  }, help));
};
MultiSelect.propTypes = {
  disabled: _pt.bool,
  error: _pt.string,
  selectedItems: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })),
  help: _pt.node,
  helpClassName: _pt.string,
  label: _pt.oneOfType([_pt.string, _pt.oneOf([null])]),
  listSelected: _pt.bool,
  onDeselectItem: _pt.func,
  onItemsUpdate: _pt.func,
  onSelectItem: _pt.func,
  placeholder: _pt.string,
  required: _pt.bool,
  items: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })).isRequired,
  disabledItems: _pt.arrayOf(_pt.shape({
    label: _pt.string.isRequired,
    value: _pt.oneOfType([_pt.string, _pt.number]).isRequired,
    group: _pt.string
  })),
  renderItem: _pt.func,
  dropdownHeader: _pt.node,
  dropdownFooter: _pt.node,
  showDropdownFooter: _pt.bool,
  variant: _pt.oneOf(["condensed", "search"]),
  scrollOverflow: _pt.bool,
  isSortedAlphabetically: _pt.bool,
  hasSelectedItemsFirst: _pt.bool,
  id: _pt.string
};