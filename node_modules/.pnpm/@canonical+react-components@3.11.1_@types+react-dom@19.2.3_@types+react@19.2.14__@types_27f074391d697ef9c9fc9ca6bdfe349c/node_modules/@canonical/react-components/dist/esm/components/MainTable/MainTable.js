var _excluded = ["content", "sortKey"],
  _excluded2 = ["columns", "expanded", "expandedContent", "key", "sortData"],
  _excluded3 = ["content"],
  _excluded4 = ["defaultSort", "defaultSortDirection", "emptyStateMsg", "expanding", "headers", "onUpdateSort", "paginate", "rows", "responsive", "sortable", "sortFunction", "hiddenCaption"];
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
import React, { useEffect, useMemo, useState } from "react";
import Pagination from "../Pagination";
import Table from "../Table";
import TableRow from "../TableRow";
import TableHeader from "../TableHeader";
import TableCell from "../TableCell";
import { usePagination } from "../../hooks";
var updateSort = (setSortKey, setSortDirection, sortKey, sortDirection) => {
  var newDirection = null;
  if (sortDirection === "none") {
    newDirection = "ascending";
  } else if (sortDirection === "ascending") {
    newDirection = "descending";
  } else {
    sortKey = null;
  }
  setSortKey(sortKey);
  setSortDirection(newDirection);
};
var generateHeaders = (currentSortKey, currentSortDirection, expanding, headers, sortable, setSortKey, setSortDirection) => {
  var headerItems = headers.map((_ref, index) => {
    var {
        content,
        sortKey
      } = _ref,
      props = _objectWithoutProperties(_ref, _excluded);
    var sortDirection;
    if (sortable && sortKey) {
      if (currentSortKey === sortKey) {
        sortDirection = currentSortDirection;
      } else {
        sortDirection = "none";
      }
    }
    return /*#__PURE__*/React.createElement(TableHeader, _extends({
      key: index,
      sort: sortDirection,
      onClick: sortable && sortKey ? updateSort.bind(this, setSortKey, setSortDirection, sortKey, sortDirection) : undefined
    }, props), content);
  });
  // When there is expanding content then provide an extra hidden header to
  // account for the extra cell in the body rows.
  return /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement(TableRow, null, headerItems, expanding && /*#__PURE__*/React.createElement(TableHeader, {
    "aria-hidden": "true"
  }, /*#__PURE__*/React.createElement("span", {
    className: "u-off-screen"
  }, "Empty"))));
};
var generateRows = _ref2 => {
  var {
    rows,
    headers,
    responsive,
    expanding
  } = _ref2;
  return rows.map((_ref3, index) => {
    var {
        columns,
        expanded,
        expandedContent,
        key,
        sortData: _
      } = _ref3,
      rowProps = _objectWithoutProperties(_ref3, _excluded2);
    var cellItems = columns === null || columns === void 0 ? void 0 : columns.map((_ref4, index) => {
      var {
          content
        } = _ref4,
        cellProps = _objectWithoutProperties(_ref4, _excluded3);
      var headerContent = headers && headers[index]["content"];
      var headerReplacement = headers && headers[index]["heading"];
      if (responsive) {
        cellProps["data-heading"] = typeof headerContent === "string" ? headerContent : headerReplacement;
      }
      return /*#__PURE__*/React.createElement(TableCell, _extends({
        key: index
      }, cellProps), content);
    });
    // if key was not provided as a prop, use row's index instead
    if (key === null || typeof key === "undefined") {
      key = index;
    }

    // The expanding cell is alway created to match the correct number of
    // table cells in rows that do have expanding content.
    return /*#__PURE__*/React.createElement(TableRow, _extends({
      key: key
    }, rowProps), cellItems, expanding && /*#__PURE__*/React.createElement(TableCell, {
      expanding: true,
      hidden: !expanded
    }, expandedContent));
  });
};
var sortRows = _ref5 => {
  var {
    currentSortDirection,
    currentSortKey,
    rows,
    sortable,
    sortFunction
  } = _ref5;
  if (!rows) {
    return [];
  }
  // Clone the rows so we can restore the original order.
  var sortedRows = [...rows];
  if (sortable && currentSortKey) {
    if (!sortFunction) {
      sortFunction = (a, b) => {
        if (!a.sortData || !b.sortData) {
          return 0;
        }
        if (a.sortData[currentSortKey] > b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? 1 : -1;
        } else if (a.sortData[currentSortKey] < b.sortData[currentSortKey]) {
          return currentSortDirection === "ascending" ? -1 : 1;
        }
        return 0;
      };
    }
    sortedRows.sort((a, b) => sortFunction(a, b, currentSortDirection, currentSortKey));
  }
  return sortedRows;
};

/**
 * This is a [React](https://reactjs.org/) component to support many table use cases.
 */
var MainTable = _ref6 => {
  var {
      defaultSort,
      defaultSortDirection,
      emptyStateMsg = "",
      expanding,
      headers,
      onUpdateSort,
      paginate,
      rows,
      responsive,
      sortable,
      sortFunction,
      hiddenCaption
    } = _ref6,
    props = _objectWithoutProperties(_ref6, _excluded4);
  var [currentSortKey, setSortKey] = useState(defaultSort);
  var [currentSortDirection, setSortDirection] = useState(defaultSortDirection);

  // Update the current sort state if the prop changes.
  useEffect(() => {
    setSortKey(defaultSort);
  }, [defaultSort]);

  // Update the current sort direction state if the prop changes.
  useEffect(() => {
    setSortDirection(defaultSortDirection);
  }, [defaultSortDirection]);
  var updateSort = newSort => {
    setSortKey(newSort);
    onUpdateSort && onUpdateSort(newSort);
  };
  var sortedRows = useMemo(() => sortRows({
    currentSortDirection,
    currentSortKey,
    rows,
    sortable,
    sortFunction
  }), [currentSortDirection, currentSortKey, rows, sortable, sortFunction]);
  var {
    pageData: finalRows,
    currentPage,
    paginate: setCurrentPage
  } = usePagination(sortedRows, {
    itemsPerPage: paginate,
    autoResetPage: true
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Table, _extends({
    expanding: expanding,
    responsive: responsive
  }, props), hiddenCaption && /*#__PURE__*/React.createElement("caption", {
    "data-testid": "hidden-caption",
    style: {
      height: "1px",
      left: "-1000px",
      overflow: "hidden",
      position: "absolute",
      top: "auto",
      width: "1px"
    }
  }, hiddenCaption), !!headers && generateHeaders(currentSortKey, currentSortDirection, expanding, headers, sortable, updateSort, setSortDirection),
  // If the table has no rows, return empty state message
  Object.entries(finalRows).length === 0 && emptyStateMsg ? /*#__PURE__*/React.createElement("caption", null, emptyStateMsg) : /*#__PURE__*/React.createElement("tbody", null, generateRows({
    rows: finalRows,
    headers,
    responsive,
    expanding
  }))), paginate && rows && rows.length > 0 && /*#__PURE__*/React.createElement(Pagination, {
    currentPage: currentPage,
    itemsPerPage: paginate,
    paginate: setCurrentPage,
    style: {
      marginTop: "1rem"
    },
    totalItems: rows.length
  }));
};
export default MainTable;